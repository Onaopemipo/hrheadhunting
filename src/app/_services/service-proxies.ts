/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.3.0 (NJsonSchema v10.4.4.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    applicantSignUp(body: ManageJobSeekerRegDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/ApplicantSignUp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApplicantSignUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApplicantSignUp(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processApplicantSignUp(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    employerSignUp(body: ManageEmployerDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/EmployerSignUp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployerSignUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployerSignUp(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processEmployerSignUp(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getToken(body: UserLoginDTO | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Account/GetToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToken(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetToken(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }

    /**
     * @param email (optional) 
     * @return Success
     */
    forgotPassword(email: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/ForgotPassword?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResestPasswordDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param token (optional) 
     * @return Success
     */
    confirmEmail(userId: string | null | undefined, token: string | null | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Account/ConfirmEmail?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmEmail(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmEmail(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }
}

@Injectable()
export class ActivityLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @param moduleName (optional) 
     * @param operationType (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchActivityLog(id: number | undefined, moduleName: string | null | undefined, operationType: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ActivityLogIListApiResult> {
        let url_ = this.baseUrl + "/api/ActivityLog/FetchActivityLog?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (moduleName !== undefined && moduleName !== null)
            url_ += "ModuleName=" + encodeURIComponent("" + moduleName) + "&";
        if (operationType !== undefined && operationType !== null)
            url_ += "OperationType=" + encodeURIComponent("" + operationType) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchActivityLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchActivityLog(<any>response_);
                } catch (e) {
                    return <Observable<ActivityLogIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityLogIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchActivityLog(response: HttpResponseBase): Observable<ActivityLogIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityLogIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityLogIListApiResult>(<any>null);
    }
}

@Injectable()
export class CertificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * API for adding/updating Certification
     * @param body (optional) 
     * @return Success
     */
    addUpdateCertification(body: ManageCertificationDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Certification/AddUpdateCertification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateCertification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateCertification(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateCertification(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch Certifications.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @param professionalBodyId (optional) 
     * @return Success
     */
    getAllCertifications(pageSize: number | undefined, pageNumber: number | undefined, professionalBodyId: number | undefined): Observable<CertificationDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Certification/GetAllCertifications?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (professionalBodyId === null)
            throw new Error("The parameter 'professionalBodyId' cannot be null.");
        else if (professionalBodyId !== undefined)
            url_ += "ProfessionalBodyId=" + encodeURIComponent("" + professionalBodyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCertifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCertifications(<any>response_);
                } catch (e) {
                    return <Observable<CertificationDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CertificationDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCertifications(response: HttpResponseBase): Observable<CertificationDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CertificationDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CertificationDTOListApiResult>(<any>null);
    }

    /**
     * API to get Certification by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getCertificationById(id: number | undefined): Observable<CertificationDTOApiResult> {
        let url_ = this.baseUrl + "/api/Certification/GetCertificationById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCertificationById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCertificationById(<any>response_);
                } catch (e) {
                    return <Observable<CertificationDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CertificationDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCertificationById(response: HttpResponseBase): Observable<CertificationDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CertificationDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CertificationDTOApiResult>(<any>null);
    }
}

@Injectable()
export class CommunicationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * API to Fetch Email Settings.
    Note: all filter are optional
     * @return Success
     */
    getAllEmailSettings(): Observable<EmailSettingListApiResult> {
        let url_ = this.baseUrl + "/api/Communication/GetAllEmailSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEmailSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEmailSettings(<any>response_);
                } catch (e) {
                    return <Observable<EmailSettingListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmailSettingListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEmailSettings(response: HttpResponseBase): Observable<EmailSettingListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailSettingListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailSettingListApiResult>(<any>null);
    }

    /**
     * API to get EmailSetting by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getEmailSettingById(id: number | undefined): Observable<EmailSettingApiResult> {
        let url_ = this.baseUrl + "/api/Communication/GetEmailSettingById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailSettingById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailSettingById(<any>response_);
                } catch (e) {
                    return <Observable<EmailSettingApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmailSettingApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailSettingById(response: HttpResponseBase): Observable<EmailSettingApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailSettingApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailSettingApiResult>(<any>null);
    }

    /**
     * API for adding/updating EmailSettings
     * @param body (optional) 
     * @return Success
     */
    addUpdateEmailSetting(body: EmailSetting | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Communication/AddUpdateEmailSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateEmailSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateEmailSetting(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateEmailSetting(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch TemplateTypes (Promotion, Account Creation etc.) for Dropdowns
    while adding Email Template
     * @return Success
     */
    getAllTemplateTypes(): Observable<IDTextViewModelListApiResult> {
        let url_ = this.baseUrl + "/api/Communication/GetAllTemplateTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTemplateTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTemplateTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTemplateTypes(response: HttpResponseBase): Observable<IDTextViewModelListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelListApiResult>(<any>null);
    }

    /**
     * API for adding/updating EmailTemplate
     * @param body (optional) 
     * @return Success
     */
    addUpdateEmailTemplate(body: ManageMailTemplateDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Communication/AddUpdateEmailTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateEmailTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateEmailTemplate(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateEmailTemplate(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch Email Templates.
    Note: all filter are optional
     * @return Success
     */
    getAllEmailTemplates(): Observable<MailTemplateDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Communication/GetAllEmailTemplates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEmailTemplates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEmailTemplates(<any>response_);
                } catch (e) {
                    return <Observable<MailTemplateDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MailTemplateDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEmailTemplates(response: HttpResponseBase): Observable<MailTemplateDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MailTemplateDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MailTemplateDTOListApiResult>(<any>null);
    }

    /**
     * API to get EmailTemplate by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getEmailTemplateById(id: number | undefined): Observable<MailTemplateDTOApiResult> {
        let url_ = this.baseUrl + "/api/Communication/GetEmailTemplateById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailTemplateById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailTemplateById(<any>response_);
                } catch (e) {
                    return <Observable<MailTemplateDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MailTemplateDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailTemplateById(response: HttpResponseBase): Observable<MailTemplateDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MailTemplateDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MailTemplateDTOApiResult>(<any>null);
    }

    /**
     * API for retrieving all Email Logs by email log filtering parameter
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param emailTo (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchEmailLogs(startDate: Date | null | undefined, endDate: Date | null | undefined, emailTo: string | null | undefined, pageSize: number | undefined): Observable<EmailLogDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Communication/FetchEmailLogs?";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (emailTo !== undefined && emailTo !== null)
            url_ += "EmailTo=" + encodeURIComponent("" + emailTo) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchEmailLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchEmailLogs(<any>response_);
                } catch (e) {
                    return <Observable<EmailLogDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmailLogDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchEmailLogs(response: HttpResponseBase): Observable<EmailLogDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailLogDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailLogDTOIListApiResult>(<any>null);
    }

    /**
     * API for getting Single EmailLog Details by id for CRUD Operation
     * @param id (optional) 
     * @return Success
     */
    fetchEmailLogById(id: number | undefined): Observable<EmailLogDTOApiResult> {
        let url_ = this.baseUrl + "/api/Communication/FetchEmailLogById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchEmailLogById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchEmailLogById(<any>response_);
                } catch (e) {
                    return <Observable<EmailLogDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmailLogDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchEmailLogById(response: HttpResponseBase): Observable<EmailLogDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailLogDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailLogDTOApiResult>(<any>null);
    }
}

@Injectable()
export class CountriesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @param searchType (optional) 
     * @param searchText (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    fetchAllCountries(id: number | undefined, searchType: string | null | undefined, searchText: string | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<CountryIListOdataResult> {
        let url_ = this.baseUrl + "/api/Countries/FetchAllCountries?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (searchType !== undefined && searchType !== null)
            url_ += "SearchType=" + encodeURIComponent("" + searchType) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchAllCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchAllCountries(<any>response_);
                } catch (e) {
                    return <Observable<CountryIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchAllCountries(response: HttpResponseBase): Observable<CountryIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryIListOdataResult>(<any>null);
    }

    /**
     * @return Success
     */
    fetchCountries(): Observable<IDTextViewModelIListOdataResult> {
        let url_ = this.baseUrl + "/api/Countries/FetchCountries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchCountries(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchCountries(response: HttpResponseBase): Observable<IDTextViewModelIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCountry(body: Country | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Countries/CreateCountry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCountry(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCountry(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteCountry(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Countries/DeleteCountry?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCountry(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCountry(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CourseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @param searchType (optional) 
     * @param searchText (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    fetchAllCourses(id: number | undefined, searchType: string | null | undefined, searchText: string | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<CourseIListOdataResult> {
        let url_ = this.baseUrl + "/api/Course/FetchAllCourses?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (searchType !== undefined && searchType !== null)
            url_ += "SearchType=" + encodeURIComponent("" + searchType) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchAllCourses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchAllCourses(<any>response_);
                } catch (e) {
                    return <Observable<CourseIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CourseIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchAllCourses(response: HttpResponseBase): Observable<CourseIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CourseIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CourseIListOdataResult>(<any>null);
    }

    /**
     * @return Success
     */
    fetchCourses(): Observable<IDTextViewModelIListOdataResult> {
        let url_ = this.baseUrl + "/api/Course/FetchCourses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchCourses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchCourses(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchCourses(response: HttpResponseBase): Observable<IDTextViewModelIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCourse(body: Course | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Course/CreateCourse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCourse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCourse(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCourse(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteCourse(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Course/DeleteCourse?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCourse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCourse(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCourse(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CurrenciesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @param searchType (optional) 
     * @param searchText (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    fetchAllCurrencies(id: number | undefined, searchType: string | null | undefined, searchText: string | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<CurrencyIListOdataResult> {
        let url_ = this.baseUrl + "/api/Currencies/FetchAllCurrencies?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (searchType !== undefined && searchType !== null)
            url_ += "SearchType=" + encodeURIComponent("" + searchType) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchAllCurrencies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchAllCurrencies(<any>response_);
                } catch (e) {
                    return <Observable<CurrencyIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CurrencyIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchAllCurrencies(response: HttpResponseBase): Observable<CurrencyIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrencyIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrencyIListOdataResult>(<any>null);
    }

    /**
     * @return Success
     */
    fetchCurrencies(): Observable<IDTextViewModelIListOdataResult> {
        let url_ = this.baseUrl + "/api/Currencies/FetchCurrencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchCurrencies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchCurrencies(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchCurrencies(response: HttpResponseBase): Observable<IDTextViewModelIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCurrency(body: Currency | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Currencies/CreateCurrency";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCurrency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCurrency(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCurrency(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteCurrency(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Currencies/DeleteCurrency?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCurrency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCurrency(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCurrency(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class EmployerTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @param searchType (optional) 
     * @param searchText (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    fetchAllEmployerTypes(id: number | undefined, searchType: string | null | undefined, searchText: string | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<EmployerTypeIListOdataResult> {
        let url_ = this.baseUrl + "/api/EmployerTypes/FetchAllEmployerTypes?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (searchType !== undefined && searchType !== null)
            url_ += "SearchType=" + encodeURIComponent("" + searchType) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchAllEmployerTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchAllEmployerTypes(<any>response_);
                } catch (e) {
                    return <Observable<EmployerTypeIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployerTypeIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchAllEmployerTypes(response: HttpResponseBase): Observable<EmployerTypeIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployerTypeIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployerTypeIListOdataResult>(<any>null);
    }

    /**
     * @return Success
     */
    fetchEmployerTypes(): Observable<IDTextViewModelIListOdataResult> {
        let url_ = this.baseUrl + "/api/EmployerTypes/FetchEmployerTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchEmployerTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchEmployerTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchEmployerTypes(response: HttpResponseBase): Observable<IDTextViewModelIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createEmployerType(body: EmployerType | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/EmployerTypes/CreateEmployerType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEmployerType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEmployerType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateEmployerType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteEmployerType(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/EmployerTypes/DeleteEmployerType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEmployerType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEmployerType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEmployerType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class GradesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @param searchType (optional) 
     * @param searchText (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    fetchAllGrades(id: number | undefined, searchType: string | null | undefined, searchText: string | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<GradeIListOdataResult> {
        let url_ = this.baseUrl + "/api/Grades/FetchAllGrades?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (searchType !== undefined && searchType !== null)
            url_ += "SearchType=" + encodeURIComponent("" + searchType) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchAllGrades(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchAllGrades(<any>response_);
                } catch (e) {
                    return <Observable<GradeIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GradeIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchAllGrades(response: HttpResponseBase): Observable<GradeIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeIListOdataResult>(<any>null);
    }

    /**
     * @return Success
     */
    fetchGrades(): Observable<IDTextViewModelIListOdataResult> {
        let url_ = this.baseUrl + "/api/Grades/FetchGrades";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchGrades(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchGrades(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchGrades(response: HttpResponseBase): Observable<IDTextViewModelIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createGrade(body: Grade | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Grades/CreateGrade";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateGrade(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateGrade(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateGrade(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteGrade(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Grades/DeleteGrade?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGrade(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGrade(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteGrade(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class InstitutionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @param searchType (optional) 
     * @param searchText (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    fetchAllInstitutions(id: number | undefined, searchType: string | null | undefined, searchText: string | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<InstitutionIListOdataResult> {
        let url_ = this.baseUrl + "/api/Institution/FetchAllInstitutions?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (searchType !== undefined && searchType !== null)
            url_ += "SearchType=" + encodeURIComponent("" + searchType) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchAllInstitutions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchAllInstitutions(<any>response_);
                } catch (e) {
                    return <Observable<InstitutionIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InstitutionIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchAllInstitutions(response: HttpResponseBase): Observable<InstitutionIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InstitutionIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InstitutionIListOdataResult>(<any>null);
    }

    /**
     * @return Success
     */
    fetchInstitutions(): Observable<IDTextViewModelIListOdataResult> {
        let url_ = this.baseUrl + "/api/Institution/FetchInstitutions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchInstitutions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchInstitutions(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchInstitutions(response: HttpResponseBase): Observable<IDTextViewModelIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createInstitution(body: Institution | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Institution/CreateInstitution";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInstitution(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateInstitution(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteInstitution(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Institution/DeleteInstitution?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInstitution(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteInstitution(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class JobServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    postJob(body: Job | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Job/PostJob";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostJob(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPostJob(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class JobTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @param searchType (optional) 
     * @param searchText (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    fetchAllJobTypes(id: number | undefined, searchType: string | null | undefined, searchText: string | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<JobTypeIListOdataResult> {
        let url_ = this.baseUrl + "/api/JobTypes/FetchAllJobTypes?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (searchType !== undefined && searchType !== null)
            url_ += "SearchType=" + encodeURIComponent("" + searchType) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchAllJobTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchAllJobTypes(<any>response_);
                } catch (e) {
                    return <Observable<JobTypeIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobTypeIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchAllJobTypes(response: HttpResponseBase): Observable<JobTypeIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobTypeIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobTypeIListOdataResult>(<any>null);
    }

    /**
     * @return Success
     */
    fetchJobTypes(): Observable<IDTextViewModelIListOdataResult> {
        let url_ = this.baseUrl + "/api/JobTypes/FetchJobTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchJobTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchJobTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchJobTypes(response: HttpResponseBase): Observable<IDTextViewModelIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createJobType(body: JobType | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/JobTypes/CreateJobType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateJobType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateJobType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateJobType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteJobType(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/JobTypes/DeleteJobType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteJobType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteJobType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteJobType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ProfessionalBodyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * API for adding/updating Professional Body
     * @param body (optional) 
     * @return Success
     */
    addUpdateProfessionalBody(body: ManageProfessionalBodyDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ProfessionalBody/AddUpdateProfessionalBody";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateProfessionalBody(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateProfessionalBody(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateProfessionalBody(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch Professional Bodies.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @param sectorId (optional) 
     * @return Success
     */
    getAllProfessionalBodies(pageSize: number | undefined, pageNumber: number | undefined, sectorId: number | undefined): Observable<ProfessionalBodyDTOListApiResult> {
        let url_ = this.baseUrl + "/api/ProfessionalBody/GetAllProfessionalBodies?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (sectorId === null)
            throw new Error("The parameter 'sectorId' cannot be null.");
        else if (sectorId !== undefined)
            url_ += "SectorId=" + encodeURIComponent("" + sectorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProfessionalBodies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProfessionalBodies(<any>response_);
                } catch (e) {
                    return <Observable<ProfessionalBodyDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfessionalBodyDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProfessionalBodies(response: HttpResponseBase): Observable<ProfessionalBodyDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfessionalBodyDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfessionalBodyDTOListApiResult>(<any>null);
    }

    /**
     * API to get Professional Body by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getProfessionalBodyById(id: number | undefined): Observable<ProfessionalBodyDTOApiResult> {
        let url_ = this.baseUrl + "/api/ProfessionalBody/GetProfessionalBodyById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfessionalBodyById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfessionalBodyById(<any>response_);
                } catch (e) {
                    return <Observable<ProfessionalBodyDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfessionalBodyDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfessionalBodyById(response: HttpResponseBase): Observable<ProfessionalBodyDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfessionalBodyDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfessionalBodyDTOApiResult>(<any>null);
    }
}

@Injectable()
export class QualificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @param searchType (optional) 
     * @param searchText (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    fetchAllQualifications(id: number | undefined, searchType: string | null | undefined, searchText: string | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<QualificationIListOdataResult> {
        let url_ = this.baseUrl + "/api/Qualification/FetchAllQualifications?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (searchType !== undefined && searchType !== null)
            url_ += "SearchType=" + encodeURIComponent("" + searchType) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchAllQualifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchAllQualifications(<any>response_);
                } catch (e) {
                    return <Observable<QualificationIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<QualificationIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchAllQualifications(response: HttpResponseBase): Observable<QualificationIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QualificationIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QualificationIListOdataResult>(<any>null);
    }

    /**
     * @return Success
     */
    fetchQualifications(): Observable<IDTextViewModelIListOdataResult> {
        let url_ = this.baseUrl + "/api/Qualification/FetchQualifications";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchQualifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchQualifications(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchQualifications(response: HttpResponseBase): Observable<IDTextViewModelIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createQualification(body: Qualification | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Qualification/CreateQualification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateQualification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateQualification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateQualification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteQualification(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Qualification/DeleteQualification?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteQualification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteQualification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteQualification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ApiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * API for getting all Roles for creating/updating Admin User as a Tenant Admin
     * @return Success
     */
    roleGet(): Observable<ApplicationRoleDTOOdataResult> {
        let url_ = this.baseUrl + "/api/Role";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRoleGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRoleGet(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationRoleDTOOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationRoleDTOOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processRoleGet(response: HttpResponseBase): Observable<ApplicationRoleDTOOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRoleDTOOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationRoleDTOOdataResult>(<any>null);
    }

    /**
     * API for Adding/Updating Roles as a Super Admin that possesses
    'Role Management' Privilege
     * @param body (optional) 
     * @return Success
     */
    rolePost(body: ApplicationRoleDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolePost(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRolePost(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    userManagementPost(body: RegisterUserDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/UserManagement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserManagementPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserManagementPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUserManagementPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    userManagementPatch(body: RegisterUserDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/UserManagement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserManagementPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserManagementPatch(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUserManagementPatch(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    userManagementGet(): Observable<ApplicationUserDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/UserManagement";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserManagementGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserManagementGet(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationUserDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationUserDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUserManagementGet(response: HttpResponseBase): Observable<ApplicationUserDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUserDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUserDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class RolePermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * @return Success
     */
    fetchRolePermissions(): Observable<RolePermissionDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/RolePermission/FetchRolePermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchRolePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchRolePermissions(<any>response_);
                } catch (e) {
                    return <Observable<RolePermissionDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RolePermissionDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchRolePermissions(response: HttpResponseBase): Observable<RolePermissionDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RolePermissionDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RolePermissionDTOIListApiResult>(<any>null);
    }

    /**
     * @param roleId (optional) 
     * @return Success
     */
    fetchRolePermission(roleId: number | undefined): Observable<RolePermissionDTOApiResult> {
        let url_ = this.baseUrl + "/api/RolePermission/FetchRolePermission?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchRolePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchRolePermission(<any>response_);
                } catch (e) {
                    return <Observable<RolePermissionDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RolePermissionDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchRolePermission(response: HttpResponseBase): Observable<RolePermissionDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RolePermissionDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RolePermissionDTOApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rolePermissionMapping(body: RolePermissionMappingDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RolePermission/RolePermissionMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolePermissionMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolePermissionMapping(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRolePermissionMapping(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class SectorsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @param searchType (optional) 
     * @param searchText (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    fetchAllSectors(id: number | undefined, searchType: string | null | undefined, searchText: string | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<SectorIListOdataResult> {
        let url_ = this.baseUrl + "/api/Sectors/FetchAllSectors?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (searchType !== undefined && searchType !== null)
            url_ += "SearchType=" + encodeURIComponent("" + searchType) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchAllSectors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchAllSectors(<any>response_);
                } catch (e) {
                    return <Observable<SectorIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SectorIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchAllSectors(response: HttpResponseBase): Observable<SectorIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SectorIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SectorIListOdataResult>(<any>null);
    }

    /**
     * @return Success
     */
    fetchSectors(): Observable<IDTextViewModelIListOdataResult> {
        let url_ = this.baseUrl + "/api/Sectors/FetchSectors";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchSectors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchSectors(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchSectors(response: HttpResponseBase): Observable<IDTextViewModelIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSector(body: Sector | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Sectors/CreateSector";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSector(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSector(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteSector(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Sectors/DeleteSector?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSector(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSector(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SkillServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * API for adding Skill
     * @param body (optional) 
     * @return Success
     */
    addSkills(body: ManageSkillDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Skill/AddSkills";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSkills(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSkills(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddSkills(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch Skills.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @param categoryId (optional) 
     * @return Success
     */
    getAllSkills(pageSize: number | undefined, pageNumber: number | undefined, categoryId: number | undefined): Observable<SkillListApiResult> {
        let url_ = this.baseUrl + "/api/Skill/GetAllSkills?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSkills(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSkills(<any>response_);
                } catch (e) {
                    return <Observable<SkillListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSkills(response: HttpResponseBase): Observable<SkillListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SkillListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillListApiResult>(<any>null);
    }

    /**
     * API to get Skill by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getSkillById(id: number | undefined): Observable<SkillApiResult> {
        let url_ = this.baseUrl + "/api/Skill/GetSkillById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkillById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkillById(<any>response_);
                } catch (e) {
                    return <Observable<SkillApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkillById(response: HttpResponseBase): Observable<SkillApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SkillApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillApiResult>(<any>null);
    }
}

@Injectable()
export class SkillAreasServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @param searchType (optional) 
     * @param searchText (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    fetchAllSkillAreas(id: number | undefined, searchType: string | null | undefined, searchText: string | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<SkillAreaIListOdataResult> {
        let url_ = this.baseUrl + "/api/SkillAreas/FetchAllSkillAreas?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (searchType !== undefined && searchType !== null)
            url_ += "SearchType=" + encodeURIComponent("" + searchType) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchAllSkillAreas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchAllSkillAreas(<any>response_);
                } catch (e) {
                    return <Observable<SkillAreaIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillAreaIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchAllSkillAreas(response: HttpResponseBase): Observable<SkillAreaIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SkillAreaIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillAreaIListOdataResult>(<any>null);
    }

    /**
     * @return Success
     */
    fetchSkillAreas(): Observable<IDTextViewModelIListOdataResult> {
        let url_ = this.baseUrl + "/api/SkillAreas/FetchSkillAreas";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchSkillAreas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchSkillAreas(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchSkillAreas(response: HttpResponseBase): Observable<IDTextViewModelIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSkillArea(body: SkillArea | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/SkillAreas/CreateSkillArea";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSkillArea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSkillArea(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSkillArea(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteSkillArea(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/SkillAreas/DeleteSkillArea?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSkillArea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSkillArea(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSkillArea(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class StatesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @param searchType (optional) 
     * @param searchText (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    fetchAllStates(id: number | undefined, searchType: string | null | undefined, searchText: string | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<StateIListOdataResult> {
        let url_ = this.baseUrl + "/api/States/FetchAllStates?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (searchType !== undefined && searchType !== null)
            url_ += "SearchType=" + encodeURIComponent("" + searchType) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchAllStates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchAllStates(<any>response_);
                } catch (e) {
                    return <Observable<StateIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<StateIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchAllStates(response: HttpResponseBase): Observable<StateIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StateIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StateIListOdataResult>(<any>null);
    }

    /**
     * @return Success
     */
    fetchStates(): Observable<IDTextViewModelIListOdataResult> {
        let url_ = this.baseUrl + "/api/States/FetchStates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchStates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchStates(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchStates(response: HttpResponseBase): Observable<IDTextViewModelIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createState(body: State | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/States/CreateState";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateState(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateState(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteState(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/States/DeleteState?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteState(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteState(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SubscriptionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @param searchType (optional) 
     * @param searchText (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    fetchAllSubscriptions(id: number | undefined, searchType: string | null | undefined, searchText: string | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<SubscriptionIListOdataResult> {
        let url_ = this.baseUrl + "/api/Subscriptions/FetchAllSubscriptions?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (searchType !== undefined && searchType !== null)
            url_ += "SearchType=" + encodeURIComponent("" + searchType) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchAllSubscriptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchAllSubscriptions(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchAllSubscriptions(response: HttpResponseBase): Observable<SubscriptionIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionIListOdataResult>(<any>null);
    }

    /**
     * @return Success
     */
    fetchSubscriptions(): Observable<IDTextViewModelIListOdataResult> {
        let url_ = this.baseUrl + "/api/Subscriptions/FetchSubscriptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchSubscriptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchSubscriptions(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchSubscriptions(response: HttpResponseBase): Observable<IDTextViewModelIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSubscription(body: ManageSubscriptionDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Subscriptions/CreateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteSubscription(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Subscriptions/DeleteSubscription?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TitlesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @param searchType (optional) 
     * @param searchText (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    fetchAllTitles(id: number | undefined, searchType: string | null | undefined, searchText: string | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<TitleIListOdataResult> {
        let url_ = this.baseUrl + "/api/Titles/FetchAllTitles?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (searchType !== undefined && searchType !== null)
            url_ += "SearchType=" + encodeURIComponent("" + searchType) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchAllTitles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchAllTitles(<any>response_);
                } catch (e) {
                    return <Observable<TitleIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TitleIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchAllTitles(response: HttpResponseBase): Observable<TitleIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TitleIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TitleIListOdataResult>(<any>null);
    }

    /**
     * @return Success
     */
    fetchTitles(): Observable<IDTextViewModelIListOdataResult> {
        let url_ = this.baseUrl + "/api/Titles/FetchTitles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchTitles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchTitles(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchTitles(response: HttpResponseBase): Observable<IDTextViewModelIListOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTitle(body: Title | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Titles/CreateTitle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTitle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTitle(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTitle(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTitle(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Titles/DeleteTitle?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTitle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTitle(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTitle(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export class ManageJobSeekerRegDTO implements IManageJobSeekerRegDTO {
    id!: number;
    titleId!: number;
    isSocial!: boolean;
    firstName!: string;
    lastname!: string;
    email!: string | undefined;
    dateOfBirth!: Date;
    genderId!: number;
    nationalityId!: number;
    residentialStateId!: number;
    phoneNumber!: string | undefined;
    password!: string;
    fieldOfInterestId!: number;
    stateOfInterestId!: number;
    yearOfExperience!: number;
    availabilityDuration!: number;
    qualificationId!: number;
    courseOfStudyId!: number;
    institutionId!: number;
    institutionName!: string | undefined;
    gradeId!: number;
    qualificationStartDate!: Date;
    qualificationEndDate!: Date;
    currentJobTitle!: string | undefined;
    companyName!: string | undefined;
    workStartDate!: Date;
    workEndDate!: Date | undefined;
    isPresentEmployment!: boolean;
    resume!: string | undefined;
    videoResume!: string | undefined;
    briefDescription!: string | undefined;
    readonly title!: string | undefined;
    readonly sex!: string | undefined;

    constructor(data?: IManageJobSeekerRegDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.titleId = _data["titleId"];
            this.isSocial = _data["isSocial"];
            this.firstName = _data["firstName"];
            this.lastname = _data["lastname"];
            this.email = _data["email"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.genderId = _data["genderId"];
            this.nationalityId = _data["nationalityId"];
            this.residentialStateId = _data["residentialStateId"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
            this.fieldOfInterestId = _data["fieldOfInterestId"];
            this.stateOfInterestId = _data["stateOfInterestId"];
            this.yearOfExperience = _data["yearOfExperience"];
            this.availabilityDuration = _data["availabilityDuration"];
            this.qualificationId = _data["qualificationId"];
            this.courseOfStudyId = _data["courseOfStudyId"];
            this.institutionId = _data["institutionId"];
            this.institutionName = _data["institutionName"];
            this.gradeId = _data["gradeId"];
            this.qualificationStartDate = _data["qualificationStartDate"] ? new Date(_data["qualificationStartDate"].toString()) : <any>undefined;
            this.qualificationEndDate = _data["qualificationEndDate"] ? new Date(_data["qualificationEndDate"].toString()) : <any>undefined;
            this.currentJobTitle = _data["currentJobTitle"];
            this.companyName = _data["companyName"];
            this.workStartDate = _data["workStartDate"] ? new Date(_data["workStartDate"].toString()) : <any>undefined;
            this.workEndDate = _data["workEndDate"] ? new Date(_data["workEndDate"].toString()) : <any>undefined;
            this.isPresentEmployment = _data["isPresentEmployment"];
            this.resume = _data["resume"];
            this.videoResume = _data["videoResume"];
            this.briefDescription = _data["briefDescription"];
            (<any>this).title = _data["title"];
            (<any>this).sex = _data["sex"];
        }
    }

    static fromJS(data: any): ManageJobSeekerRegDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageJobSeekerRegDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["titleId"] = this.titleId;
        data["isSocial"] = this.isSocial;
        data["firstName"] = this.firstName;
        data["lastname"] = this.lastname;
        data["email"] = this.email;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["genderId"] = this.genderId;
        data["nationalityId"] = this.nationalityId;
        data["residentialStateId"] = this.residentialStateId;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["fieldOfInterestId"] = this.fieldOfInterestId;
        data["stateOfInterestId"] = this.stateOfInterestId;
        data["yearOfExperience"] = this.yearOfExperience;
        data["availabilityDuration"] = this.availabilityDuration;
        data["qualificationId"] = this.qualificationId;
        data["courseOfStudyId"] = this.courseOfStudyId;
        data["institutionId"] = this.institutionId;
        data["institutionName"] = this.institutionName;
        data["gradeId"] = this.gradeId;
        data["qualificationStartDate"] = this.qualificationStartDate ? this.qualificationStartDate.toISOString() : <any>undefined;
        data["qualificationEndDate"] = this.qualificationEndDate ? this.qualificationEndDate.toISOString() : <any>undefined;
        data["currentJobTitle"] = this.currentJobTitle;
        data["companyName"] = this.companyName;
        data["workStartDate"] = this.workStartDate ? this.workStartDate.toISOString() : <any>undefined;
        data["workEndDate"] = this.workEndDate ? this.workEndDate.toISOString() : <any>undefined;
        data["isPresentEmployment"] = this.isPresentEmployment;
        data["resume"] = this.resume;
        data["videoResume"] = this.videoResume;
        data["briefDescription"] = this.briefDescription;
        data["title"] = this.title;
        data["sex"] = this.sex;
        return data; 
    }

    clone(): ManageJobSeekerRegDTO {
        const json = this.toJSON();
        let result = new ManageJobSeekerRegDTO();
        result.init(json);
        return result;
    }
}

export interface IManageJobSeekerRegDTO {
    id: number;
    titleId: number;
    isSocial: boolean;
    firstName: string;
    lastname: string;
    email: string | undefined;
    dateOfBirth: Date;
    genderId: number;
    nationalityId: number;
    residentialStateId: number;
    phoneNumber: string | undefined;
    password: string;
    fieldOfInterestId: number;
    stateOfInterestId: number;
    yearOfExperience: number;
    availabilityDuration: number;
    qualificationId: number;
    courseOfStudyId: number;
    institutionId: number;
    institutionName: string | undefined;
    gradeId: number;
    qualificationStartDate: Date;
    qualificationEndDate: Date;
    currentJobTitle: string | undefined;
    companyName: string | undefined;
    workStartDate: Date;
    workEndDate: Date | undefined;
    isPresentEmployment: boolean;
    resume: string | undefined;
    videoResume: string | undefined;
    briefDescription: string | undefined;
    title: string | undefined;
    sex: string | undefined;
}

export class MessageOut implements IMessageOut {
    message!: string | undefined;
    isSuccessful!: boolean;
    retId!: number;
    bulkUploadId!: number;
    bulkUploadHtmlData!: string | undefined;
    redirectUrl!: string | undefined;
    referenceNumber!: string | undefined;
    errors!: string[] | undefined;

    constructor(data?: IMessageOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.isSuccessful = _data["isSuccessful"];
            this.retId = _data["retId"];
            this.bulkUploadId = _data["bulkUploadId"];
            this.bulkUploadHtmlData = _data["bulkUploadHtmlData"];
            this.redirectUrl = _data["redirectUrl"];
            this.referenceNumber = _data["referenceNumber"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): MessageOut {
        data = typeof data === 'object' ? data : {};
        let result = new MessageOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["isSuccessful"] = this.isSuccessful;
        data["retId"] = this.retId;
        data["bulkUploadId"] = this.bulkUploadId;
        data["bulkUploadHtmlData"] = this.bulkUploadHtmlData;
        data["redirectUrl"] = this.redirectUrl;
        data["referenceNumber"] = this.referenceNumber;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }

    clone(): MessageOut {
        const json = this.toJSON();
        let result = new MessageOut();
        result.init(json);
        return result;
    }
}

export interface IMessageOut {
    message: string | undefined;
    isSuccessful: boolean;
    retId: number;
    bulkUploadId: number;
    bulkUploadHtmlData: string | undefined;
    redirectUrl: string | undefined;
    referenceNumber: string | undefined;
    errors: string[] | undefined;
}

export class MessageOutApiResult implements IMessageOutApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: MessageOut;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IMessageOutApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? MessageOut.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): MessageOutApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new MessageOutApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): MessageOutApiResult {
        const json = this.toJSON();
        let result = new MessageOutApiResult();
        result.init(json);
        return result;
    }
}

export interface IMessageOutApiResult {
    hasError: boolean;
    message: string | undefined;
    result: MessageOut;
    totalCount: number;
    totalRecord: number;
}

export class ManageEmployerDTO implements IManageEmployerDTO {
    id!: number;
    name!: string;
    firstName!: string;
    lastName!: string;
    subscriptionPlanId!: number;
    isTrial!: boolean;
    tempRef!: string | undefined;
    contactPerson!: string;
    email!: string;
    password!: string;
    confirmPassword!: string;
    mobile!: string | undefined;
    sectorId!: number;
    logo!: string | undefined;
    employerTypeId!: number;

    constructor(data?: IManageEmployerDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.isTrial = _data["isTrial"];
            this.tempRef = _data["tempRef"];
            this.contactPerson = _data["contactPerson"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            this.mobile = _data["mobile"];
            this.sectorId = _data["sectorId"];
            this.logo = _data["logo"];
            this.employerTypeId = _data["employerTypeId"];
        }
    }

    static fromJS(data: any): ManageEmployerDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageEmployerDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["isTrial"] = this.isTrial;
        data["tempRef"] = this.tempRef;
        data["contactPerson"] = this.contactPerson;
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        data["mobile"] = this.mobile;
        data["sectorId"] = this.sectorId;
        data["logo"] = this.logo;
        data["employerTypeId"] = this.employerTypeId;
        return data; 
    }

    clone(): ManageEmployerDTO {
        const json = this.toJSON();
        let result = new ManageEmployerDTO();
        result.init(json);
        return result;
    }
}

export interface IManageEmployerDTO {
    id: number;
    name: string;
    firstName: string;
    lastName: string;
    subscriptionPlanId: number;
    isTrial: boolean;
    tempRef: string | undefined;
    contactPerson: string;
    email: string;
    password: string;
    confirmPassword: string;
    mobile: string | undefined;
    sectorId: number;
    logo: string | undefined;
    employerTypeId: number;
}

export class UserLoginDTO implements IUserLoginDTO {
    email!: string | undefined;
    password!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    isSocial!: boolean;

    constructor(data?: IUserLoginDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.isSocial = _data["isSocial"];
        }
    }

    static fromJS(data: any): UserLoginDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["isSocial"] = this.isSocial;
        return data; 
    }

    clone(): UserLoginDTO {
        const json = this.toJSON();
        let result = new UserLoginDTO();
        result.init(json);
        return result;
    }
}

export interface IUserLoginDTO {
    email: string | undefined;
    password: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    isSocial: boolean;
}

export class CompanyUserCache implements ICompanyUserCache {
    companyId!: number;
    totalJobPosted!: number;
    userId!: number;
    isAdmin!: boolean;
    isTenantAdmin!: boolean;
    isSuperAdmin!: boolean;
    name!: string | undefined;
    contactPerson!: string | undefined;
    firstName!: string | undefined;
    lastname!: string | undefined;
    email!: string | undefined;
    mobile!: string | undefined;
    nowRecruiting!: boolean;
    employerTypeId!: number;
    registered!: boolean;
    sectorId!: number;
    subsidiaryId!: number;
    subscriptionPlanId!: number;
    subscriptionPlanName!: string | undefined;
    lastBillingDate!: Date | undefined;
    lastPaymentDate!: Date | undefined;
    userDisplayName!: string | undefined;
    isTrial!: boolean;
    isPlanActivated!: boolean;
    hasPostedJob!: boolean;
    hasActivePremiumJob!: boolean;

    constructor(data?: ICompanyUserCache) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.totalJobPosted = _data["totalJobPosted"];
            this.userId = _data["userId"];
            this.isAdmin = _data["isAdmin"];
            this.isTenantAdmin = _data["isTenantAdmin"];
            this.isSuperAdmin = _data["isSuperAdmin"];
            this.name = _data["name"];
            this.contactPerson = _data["contactPerson"];
            this.firstName = _data["firstName"];
            this.lastname = _data["lastname"];
            this.email = _data["email"];
            this.mobile = _data["mobile"];
            this.nowRecruiting = _data["nowRecruiting"];
            this.employerTypeId = _data["employerTypeId"];
            this.registered = _data["registered"];
            this.sectorId = _data["sectorId"];
            this.subsidiaryId = _data["subsidiaryId"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.subscriptionPlanName = _data["subscriptionPlanName"];
            this.lastBillingDate = _data["lastBillingDate"] ? new Date(_data["lastBillingDate"].toString()) : <any>undefined;
            this.lastPaymentDate = _data["lastPaymentDate"] ? new Date(_data["lastPaymentDate"].toString()) : <any>undefined;
            this.userDisplayName = _data["userDisplayName"];
            this.isTrial = _data["isTrial"];
            this.isPlanActivated = _data["isPlanActivated"];
            this.hasPostedJob = _data["hasPostedJob"];
            this.hasActivePremiumJob = _data["hasActivePremiumJob"];
        }
    }

    static fromJS(data: any): CompanyUserCache {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyUserCache();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["totalJobPosted"] = this.totalJobPosted;
        data["userId"] = this.userId;
        data["isAdmin"] = this.isAdmin;
        data["isTenantAdmin"] = this.isTenantAdmin;
        data["isSuperAdmin"] = this.isSuperAdmin;
        data["name"] = this.name;
        data["contactPerson"] = this.contactPerson;
        data["firstName"] = this.firstName;
        data["lastname"] = this.lastname;
        data["email"] = this.email;
        data["mobile"] = this.mobile;
        data["nowRecruiting"] = this.nowRecruiting;
        data["employerTypeId"] = this.employerTypeId;
        data["registered"] = this.registered;
        data["sectorId"] = this.sectorId;
        data["subsidiaryId"] = this.subsidiaryId;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["subscriptionPlanName"] = this.subscriptionPlanName;
        data["lastBillingDate"] = this.lastBillingDate ? this.lastBillingDate.toISOString() : <any>undefined;
        data["lastPaymentDate"] = this.lastPaymentDate ? this.lastPaymentDate.toISOString() : <any>undefined;
        data["userDisplayName"] = this.userDisplayName;
        data["isTrial"] = this.isTrial;
        data["isPlanActivated"] = this.isPlanActivated;
        data["hasPostedJob"] = this.hasPostedJob;
        data["hasActivePremiumJob"] = this.hasActivePremiumJob;
        return data; 
    }

    clone(): CompanyUserCache {
        const json = this.toJSON();
        let result = new CompanyUserCache();
        result.init(json);
        return result;
    }
}

export interface ICompanyUserCache {
    companyId: number;
    totalJobPosted: number;
    userId: number;
    isAdmin: boolean;
    isTenantAdmin: boolean;
    isSuperAdmin: boolean;
    name: string | undefined;
    contactPerson: string | undefined;
    firstName: string | undefined;
    lastname: string | undefined;
    email: string | undefined;
    mobile: string | undefined;
    nowRecruiting: boolean;
    employerTypeId: number;
    registered: boolean;
    sectorId: number;
    subsidiaryId: number;
    subscriptionPlanId: number;
    subscriptionPlanName: string | undefined;
    lastBillingDate: Date | undefined;
    lastPaymentDate: Date | undefined;
    userDisplayName: string | undefined;
    isTrial: boolean;
    isPlanActivated: boolean;
    hasPostedJob: boolean;
    hasActivePremiumJob: boolean;
}

export class VwUserObj implements IVwUserObj {
    user_id!: number;
    companyProfile!: CompanyUserCache;
    first_name!: string | undefined;
    last_name!: string | undefined;
    readonly full_name!: string | undefined;
    other_name!: string | undefined;
    email!: string | undefined;
    phone_number!: string | undefined;
    email_confirmed!: boolean;
    session_token!: string | undefined;
    jwt_token!: string | undefined;
    user_token!: string | undefined;
    company_id!: number;
    company_name!: string | undefined;
    sub_id!: number;
    isAdmin!: boolean;
    isSuperAdmin!: boolean;
    isTenantAdmin!: boolean;
    isActiveBySysOrAdmin!: boolean;
    lstPermissions!: string[] | undefined;
    message!: string | undefined;
    isSuccessful!: boolean;
    retId!: number;
    bulkUploadId!: number;
    bulkUploadHtmlData!: string | undefined;
    redirectUrl!: string | undefined;
    referenceNumber!: string | undefined;
    errors!: string[] | undefined;

    constructor(data?: IVwUserObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user_id = _data["user_id"];
            this.companyProfile = _data["companyProfile"] ? CompanyUserCache.fromJS(_data["companyProfile"]) : <any>undefined;
            this.first_name = _data["first_name"];
            this.last_name = _data["last_name"];
            (<any>this).full_name = _data["full_name"];
            this.other_name = _data["other_name"];
            this.email = _data["email"];
            this.phone_number = _data["phone_number"];
            this.email_confirmed = _data["email_confirmed"];
            this.session_token = _data["session_token"];
            this.jwt_token = _data["jwt_token"];
            this.user_token = _data["user_token"];
            this.company_id = _data["company_id"];
            this.company_name = _data["company_name"];
            this.sub_id = _data["sub_id"];
            this.isAdmin = _data["isAdmin"];
            this.isSuperAdmin = _data["isSuperAdmin"];
            this.isTenantAdmin = _data["isTenantAdmin"];
            this.isActiveBySysOrAdmin = _data["isActiveBySysOrAdmin"];
            if (Array.isArray(_data["lstPermissions"])) {
                this.lstPermissions = [] as any;
                for (let item of _data["lstPermissions"])
                    this.lstPermissions!.push(item);
            }
            this.message = _data["message"];
            this.isSuccessful = _data["isSuccessful"];
            this.retId = _data["retId"];
            this.bulkUploadId = _data["bulkUploadId"];
            this.bulkUploadHtmlData = _data["bulkUploadHtmlData"];
            this.redirectUrl = _data["redirectUrl"];
            this.referenceNumber = _data["referenceNumber"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): VwUserObj {
        data = typeof data === 'object' ? data : {};
        let result = new VwUserObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user_id"] = this.user_id;
        data["companyProfile"] = this.companyProfile ? this.companyProfile.toJSON() : <any>undefined;
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        data["full_name"] = this.full_name;
        data["other_name"] = this.other_name;
        data["email"] = this.email;
        data["phone_number"] = this.phone_number;
        data["email_confirmed"] = this.email_confirmed;
        data["session_token"] = this.session_token;
        data["jwt_token"] = this.jwt_token;
        data["user_token"] = this.user_token;
        data["company_id"] = this.company_id;
        data["company_name"] = this.company_name;
        data["sub_id"] = this.sub_id;
        data["isAdmin"] = this.isAdmin;
        data["isSuperAdmin"] = this.isSuperAdmin;
        data["isTenantAdmin"] = this.isTenantAdmin;
        data["isActiveBySysOrAdmin"] = this.isActiveBySysOrAdmin;
        if (Array.isArray(this.lstPermissions)) {
            data["lstPermissions"] = [];
            for (let item of this.lstPermissions)
                data["lstPermissions"].push(item);
        }
        data["message"] = this.message;
        data["isSuccessful"] = this.isSuccessful;
        data["retId"] = this.retId;
        data["bulkUploadId"] = this.bulkUploadId;
        data["bulkUploadHtmlData"] = this.bulkUploadHtmlData;
        data["redirectUrl"] = this.redirectUrl;
        data["referenceNumber"] = this.referenceNumber;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }

    clone(): VwUserObj {
        const json = this.toJSON();
        let result = new VwUserObj();
        result.init(json);
        return result;
    }
}

export interface IVwUserObj {
    user_id: number;
    companyProfile: CompanyUserCache;
    first_name: string | undefined;
    last_name: string | undefined;
    full_name: string | undefined;
    other_name: string | undefined;
    email: string | undefined;
    phone_number: string | undefined;
    email_confirmed: boolean;
    session_token: string | undefined;
    jwt_token: string | undefined;
    user_token: string | undefined;
    company_id: number;
    company_name: string | undefined;
    sub_id: number;
    isAdmin: boolean;
    isSuperAdmin: boolean;
    isTenantAdmin: boolean;
    isActiveBySysOrAdmin: boolean;
    lstPermissions: string[] | undefined;
    message: string | undefined;
    isSuccessful: boolean;
    retId: number;
    bulkUploadId: number;
    bulkUploadHtmlData: string | undefined;
    redirectUrl: string | undefined;
    referenceNumber: string | undefined;
    errors: string[] | undefined;
}

export class VwUserObjApiResult implements IVwUserObjApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: VwUserObj;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IVwUserObjApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? VwUserObj.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): VwUserObjApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new VwUserObjApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): VwUserObjApiResult {
        const json = this.toJSON();
        let result = new VwUserObjApiResult();
        result.init(json);
        return result;
    }
}

export interface IVwUserObjApiResult {
    hasError: boolean;
    message: string | undefined;
    result: VwUserObj;
    totalCount: number;
    totalRecord: number;
}

export class ResestPasswordDTO implements IResestPasswordDTO {
    token!: string | undefined;
    email!: string;
    password!: string;
    confirmPassword!: string | undefined;

    constructor(data?: IResestPasswordDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ResestPasswordDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResestPasswordDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data; 
    }

    clone(): ResestPasswordDTO {
        const json = this.toJSON();
        let result = new ResestPasswordDTO();
        result.init(json);
        return result;
    }
}

export interface IResestPasswordDTO {
    token: string | undefined;
    email: string;
    password: string;
    confirmPassword: string | undefined;
}

export class ActivityLog implements IActivityLog {
    userId!: number | undefined;
    moduleName!: string | undefined;
    moduleAction!: string | undefined;
    description!: string | undefined;
    record!: string | undefined;
    ipAdress!: string | undefined;
    operationType!: string | undefined;
    employeeId!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IActivityLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.moduleName = _data["moduleName"];
            this.moduleAction = _data["moduleAction"];
            this.description = _data["description"];
            this.record = _data["record"];
            this.ipAdress = _data["ipAdress"];
            this.operationType = _data["operationType"];
            this.employeeId = _data["employeeId"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ActivityLog {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["moduleName"] = this.moduleName;
        data["moduleAction"] = this.moduleAction;
        data["description"] = this.description;
        data["record"] = this.record;
        data["ipAdress"] = this.ipAdress;
        data["operationType"] = this.operationType;
        data["employeeId"] = this.employeeId;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ActivityLog {
        const json = this.toJSON();
        let result = new ActivityLog();
        result.init(json);
        return result;
    }
}

export interface IActivityLog {
    userId: number | undefined;
    moduleName: string | undefined;
    moduleAction: string | undefined;
    description: string | undefined;
    record: string | undefined;
    ipAdress: string | undefined;
    operationType: string | undefined;
    employeeId: number;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ActivityLogIListApiResult implements IActivityLogIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ActivityLog[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IActivityLogIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ActivityLog.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ActivityLogIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityLogIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ActivityLogIListApiResult {
        const json = this.toJSON();
        let result = new ActivityLogIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IActivityLogIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ActivityLog[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ManageCertificationDTO implements IManageCertificationDTO {
    id!: number;
    professionalBodyId!: number;
    name!: string | undefined;
    code!: string | undefined;
    point!: number;

    constructor(data?: IManageCertificationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.professionalBodyId = _data["professionalBodyId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.point = _data["point"];
        }
    }

    static fromJS(data: any): ManageCertificationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageCertificationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["professionalBodyId"] = this.professionalBodyId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["point"] = this.point;
        return data; 
    }

    clone(): ManageCertificationDTO {
        const json = this.toJSON();
        let result = new ManageCertificationDTO();
        result.init(json);
        return result;
    }
}

export interface IManageCertificationDTO {
    id: number;
    professionalBodyId: number;
    name: string | undefined;
    code: string | undefined;
    point: number;
}

export class CertificationDTO implements ICertificationDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    professionalBodyId!: number;
    professionalBody!: string | undefined;
    name!: string | undefined;
    code!: string | undefined;
    point!: number | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICertificationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.professionalBodyId = _data["professionalBodyId"];
            this.professionalBody = _data["professionalBody"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.point = _data["point"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): CertificationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CertificationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["professionalBodyId"] = this.professionalBodyId;
        data["professionalBody"] = this.professionalBody;
        data["name"] = this.name;
        data["code"] = this.code;
        data["point"] = this.point;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): CertificationDTO {
        const json = this.toJSON();
        let result = new CertificationDTO();
        result.init(json);
        return result;
    }
}

export interface ICertificationDTO {
    id: number;
    companyID: number;
    subID: number;
    professionalBodyId: number;
    professionalBody: string | undefined;
    name: string | undefined;
    code: string | undefined;
    point: number | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class CertificationDTOListApiResult implements ICertificationDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: CertificationDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ICertificationDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(CertificationDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): CertificationDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CertificationDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): CertificationDTOListApiResult {
        const json = this.toJSON();
        let result = new CertificationDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICertificationDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: CertificationDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class CertificationDTOApiResult implements ICertificationDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: CertificationDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ICertificationDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? CertificationDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): CertificationDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CertificationDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): CertificationDTOApiResult {
        const json = this.toJSON();
        let result = new CertificationDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ICertificationDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: CertificationDTO;
    totalCount: number;
    totalRecord: number;
}

export class EmailSetting implements IEmailSetting {
    emailUserName!: string | undefined;
    emailHost!: string | undefined;
    emailPort!: number;
    emailPassword!: string | undefined;
    enableSSLForEmail!: boolean;
    emailFromAddress!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmailSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailUserName = _data["emailUserName"];
            this.emailHost = _data["emailHost"];
            this.emailPort = _data["emailPort"];
            this.emailPassword = _data["emailPassword"];
            this.enableSSLForEmail = _data["enableSSLForEmail"];
            this.emailFromAddress = _data["emailFromAddress"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmailSetting {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailUserName"] = this.emailUserName;
        data["emailHost"] = this.emailHost;
        data["emailPort"] = this.emailPort;
        data["emailPassword"] = this.emailPassword;
        data["enableSSLForEmail"] = this.enableSSLForEmail;
        data["emailFromAddress"] = this.emailFromAddress;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmailSetting {
        const json = this.toJSON();
        let result = new EmailSetting();
        result.init(json);
        return result;
    }
}

export interface IEmailSetting {
    emailUserName: string | undefined;
    emailHost: string | undefined;
    emailPort: number;
    emailPassword: string | undefined;
    enableSSLForEmail: boolean;
    emailFromAddress: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmailSettingListApiResult implements IEmailSettingListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmailSetting[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IEmailSettingListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EmailSetting.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): EmailSettingListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): EmailSettingListApiResult {
        const json = this.toJSON();
        let result = new EmailSettingListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmailSettingListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmailSetting[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class EmailSettingApiResult implements IEmailSettingApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmailSetting;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IEmailSettingApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EmailSetting.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): EmailSettingApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): EmailSettingApiResult {
        const json = this.toJSON();
        let result = new EmailSettingApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmailSettingApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmailSetting;
    totalCount: number;
    totalRecord: number;
}

export class IDTextViewModel implements IIDTextViewModel {
    id!: number;
    text!: string | undefined;

    constructor(data?: IIDTextViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): IDTextViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new IDTextViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        return data; 
    }

    clone(): IDTextViewModel {
        const json = this.toJSON();
        let result = new IDTextViewModel();
        result.init(json);
        return result;
    }
}

export interface IIDTextViewModel {
    id: number;
    text: string | undefined;
}

export class IDTextViewModelListApiResult implements IIDTextViewModelListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: IDTextViewModel[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IIDTextViewModelListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(IDTextViewModel.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): IDTextViewModelListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new IDTextViewModelListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): IDTextViewModelListApiResult {
        const json = this.toJSON();
        let result = new IDTextViewModelListApiResult();
        result.init(json);
        return result;
    }
}

export interface IIDTextViewModelListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: IDTextViewModel[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ManageMailTemplateDTO implements IManageMailTemplateDTO {
    id!: number;
    emailTemplateTypeId!: number;
    name!: string | undefined;
    subject!: string;
    body!: string;

    constructor(data?: IManageMailTemplateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailTemplateTypeId = _data["emailTemplateTypeId"];
            this.name = _data["name"];
            this.subject = _data["subject"];
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): ManageMailTemplateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageMailTemplateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailTemplateTypeId"] = this.emailTemplateTypeId;
        data["name"] = this.name;
        data["subject"] = this.subject;
        data["body"] = this.body;
        return data; 
    }

    clone(): ManageMailTemplateDTO {
        const json = this.toJSON();
        let result = new ManageMailTemplateDTO();
        result.init(json);
        return result;
    }
}

export interface IManageMailTemplateDTO {
    id: number;
    emailTemplateTypeId: number;
    name: string | undefined;
    subject: string;
    body: string;
}

export class MailTemplateDTO implements IMailTemplateDTO {
    id!: number;
    name!: string | undefined;
    subject!: string | undefined;
    body!: string | undefined;
    emailTemplateTypeId!: number;
    templateType!: string | undefined;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IMailTemplateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.emailTemplateTypeId = _data["emailTemplateTypeId"];
            this.templateType = _data["templateType"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): MailTemplateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MailTemplateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["emailTemplateTypeId"] = this.emailTemplateTypeId;
        data["templateType"] = this.templateType;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): MailTemplateDTO {
        const json = this.toJSON();
        let result = new MailTemplateDTO();
        result.init(json);
        return result;
    }
}

export interface IMailTemplateDTO {
    id: number;
    name: string | undefined;
    subject: string | undefined;
    body: string | undefined;
    emailTemplateTypeId: number;
    templateType: string | undefined;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class MailTemplateDTOListApiResult implements IMailTemplateDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: MailTemplateDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IMailTemplateDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(MailTemplateDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): MailTemplateDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new MailTemplateDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): MailTemplateDTOListApiResult {
        const json = this.toJSON();
        let result = new MailTemplateDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IMailTemplateDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: MailTemplateDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class MailTemplateDTOApiResult implements IMailTemplateDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: MailTemplateDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IMailTemplateDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? MailTemplateDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): MailTemplateDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new MailTemplateDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): MailTemplateDTOApiResult {
        const json = this.toJSON();
        let result = new MailTemplateDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IMailTemplateDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: MailTemplateDTO;
    totalCount: number;
    totalRecord: number;
}

export class EmailLog implements IEmailLog {
    sender!: string | undefined;
    receiver!: string | undefined;
    cc!: string | undefined;
    bcc!: string | undefined;
    subject!: string | undefined;
    messageBody!: string | undefined;
    hasAttachment!: boolean;
    isSent!: boolean;
    retires!: number;
    dateSent!: Date | undefined;
    dateToSend!: Date | undefined;
    emailAttachments!: EmailLogAttachment[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmailLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sender = _data["sender"];
            this.receiver = _data["receiver"];
            this.cc = _data["cc"];
            this.bcc = _data["bcc"];
            this.subject = _data["subject"];
            this.messageBody = _data["messageBody"];
            this.hasAttachment = _data["hasAttachment"];
            this.isSent = _data["isSent"];
            this.retires = _data["retires"];
            this.dateSent = _data["dateSent"] ? new Date(_data["dateSent"].toString()) : <any>undefined;
            this.dateToSend = _data["dateToSend"] ? new Date(_data["dateToSend"].toString()) : <any>undefined;
            if (Array.isArray(_data["emailAttachments"])) {
                this.emailAttachments = [] as any;
                for (let item of _data["emailAttachments"])
                    this.emailAttachments!.push(EmailLogAttachment.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmailLog {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sender"] = this.sender;
        data["receiver"] = this.receiver;
        data["cc"] = this.cc;
        data["bcc"] = this.bcc;
        data["subject"] = this.subject;
        data["messageBody"] = this.messageBody;
        data["hasAttachment"] = this.hasAttachment;
        data["isSent"] = this.isSent;
        data["retires"] = this.retires;
        data["dateSent"] = this.dateSent ? this.dateSent.toISOString() : <any>undefined;
        data["dateToSend"] = this.dateToSend ? this.dateToSend.toISOString() : <any>undefined;
        if (Array.isArray(this.emailAttachments)) {
            data["emailAttachments"] = [];
            for (let item of this.emailAttachments)
                data["emailAttachments"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmailLog {
        const json = this.toJSON();
        let result = new EmailLog();
        result.init(json);
        return result;
    }
}

export interface IEmailLog {
    sender: string | undefined;
    receiver: string | undefined;
    cc: string | undefined;
    bcc: string | undefined;
    subject: string | undefined;
    messageBody: string | undefined;
    hasAttachment: boolean;
    isSent: boolean;
    retires: number;
    dateSent: Date | undefined;
    dateToSend: Date | undefined;
    emailAttachments: EmailLogAttachment[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmailLogAttachment implements IEmailLogAttachment {
    id!: number;
    emailLogID!: number;
    emailLog!: EmailLog;
    folderOnServer!: string | undefined;
    fileNameOnServer!: string | undefined;
    emailFileName!: string | undefined;
    dateCreated!: Date;

    constructor(data?: IEmailLogAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailLogID = _data["emailLogID"];
            this.emailLog = _data["emailLog"] ? EmailLog.fromJS(_data["emailLog"]) : <any>undefined;
            this.folderOnServer = _data["folderOnServer"];
            this.fileNameOnServer = _data["fileNameOnServer"];
            this.emailFileName = _data["emailFileName"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EmailLogAttachment {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLogAttachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailLogID"] = this.emailLogID;
        data["emailLog"] = this.emailLog ? this.emailLog.toJSON() : <any>undefined;
        data["folderOnServer"] = this.folderOnServer;
        data["fileNameOnServer"] = this.fileNameOnServer;
        data["emailFileName"] = this.emailFileName;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        return data; 
    }

    clone(): EmailLogAttachment {
        const json = this.toJSON();
        let result = new EmailLogAttachment();
        result.init(json);
        return result;
    }
}

export interface IEmailLogAttachment {
    id: number;
    emailLogID: number;
    emailLog: EmailLog;
    folderOnServer: string | undefined;
    fileNameOnServer: string | undefined;
    emailFileName: string | undefined;
    dateCreated: Date;
}

export class EmailLogDTO implements IEmailLogDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    sender!: string | undefined;
    receiver!: string | undefined;
    cc!: string | undefined;
    bcc!: string | undefined;
    subject!: string | undefined;
    messageBody!: string | undefined;
    hasAttachment!: boolean;
    isSent!: boolean;
    retires!: number;
    dateSent!: Date | undefined;
    dateToSend!: Date | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    emailAttachments!: EmailLogAttachment[] | undefined;

    constructor(data?: IEmailLogDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.sender = _data["sender"];
            this.receiver = _data["receiver"];
            this.cc = _data["cc"];
            this.bcc = _data["bcc"];
            this.subject = _data["subject"];
            this.messageBody = _data["messageBody"];
            this.hasAttachment = _data["hasAttachment"];
            this.isSent = _data["isSent"];
            this.retires = _data["retires"];
            this.dateSent = _data["dateSent"] ? new Date(_data["dateSent"].toString()) : <any>undefined;
            this.dateToSend = _data["dateToSend"] ? new Date(_data["dateToSend"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            if (Array.isArray(_data["emailAttachments"])) {
                this.emailAttachments = [] as any;
                for (let item of _data["emailAttachments"])
                    this.emailAttachments!.push(EmailLogAttachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmailLogDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLogDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["sender"] = this.sender;
        data["receiver"] = this.receiver;
        data["cc"] = this.cc;
        data["bcc"] = this.bcc;
        data["subject"] = this.subject;
        data["messageBody"] = this.messageBody;
        data["hasAttachment"] = this.hasAttachment;
        data["isSent"] = this.isSent;
        data["retires"] = this.retires;
        data["dateSent"] = this.dateSent ? this.dateSent.toISOString() : <any>undefined;
        data["dateToSend"] = this.dateToSend ? this.dateToSend.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        if (Array.isArray(this.emailAttachments)) {
            data["emailAttachments"] = [];
            for (let item of this.emailAttachments)
                data["emailAttachments"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EmailLogDTO {
        const json = this.toJSON();
        let result = new EmailLogDTO();
        result.init(json);
        return result;
    }
}

export interface IEmailLogDTO {
    id: number;
    companyID: number;
    subID: number;
    sender: string | undefined;
    receiver: string | undefined;
    cc: string | undefined;
    bcc: string | undefined;
    subject: string | undefined;
    messageBody: string | undefined;
    hasAttachment: boolean;
    isSent: boolean;
    retires: number;
    dateSent: Date | undefined;
    dateToSend: Date | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    emailAttachments: EmailLogAttachment[] | undefined;
}

export class EmailLogDTOIListApiResult implements IEmailLogDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmailLogDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IEmailLogDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EmailLogDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): EmailLogDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLogDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): EmailLogDTOIListApiResult {
        const json = this.toJSON();
        let result = new EmailLogDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmailLogDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmailLogDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class EmailLogDTOApiResult implements IEmailLogDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmailLogDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IEmailLogDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EmailLogDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): EmailLogDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLogDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): EmailLogDTOApiResult {
        const json = this.toJSON();
        let result = new EmailLogDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmailLogDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmailLogDTO;
    totalCount: number;
    totalRecord: number;
}

export class Alertmode implements IAlertmode {
    id!: number;
    name!: string | undefined;
    registeredUsers!: RegisteredUser[] | undefined;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IAlertmode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["registeredUsers"])) {
                this.registeredUsers = [] as any;
                for (let item of _data["registeredUsers"])
                    this.registeredUsers!.push(RegisteredUser.fromJS(item));
            }
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Alertmode {
        data = typeof data === 'object' ? data : {};
        let result = new Alertmode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.registeredUsers)) {
            data["registeredUsers"] = [];
            for (let item of this.registeredUsers)
                data["registeredUsers"].push(item.toJSON());
        }
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Alertmode {
        const json = this.toJSON();
        let result = new Alertmode();
        result.init(json);
        return result;
    }
}

export interface IAlertmode {
    id: number;
    name: string | undefined;
    registeredUsers: RegisteredUser[] | undefined;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Job implements IJob {
    details!: string | undefined;
    requirements!: string | undefined;
    position!: string | undefined;
    recruiter!: string | undefined;
    countryId!: number;
    stateId!: number;
    location!: string | undefined;
    jobTypeId!: number;
    minExpRequired!: number | undefined;
    maxExpRequired!: number | undefined;
    minSalary!: number | undefined;
    maxSalary!: number | undefined;
    minQualificationId!: number | undefined;
    maxQualificationId!: number | undefined;
    quizId!: number | undefined;
    currencyId!: number | undefined;
    skillAreaId!: number;
    reviewers!: string | undefined;
    clicks!: number;
    endDate!: Date;
    datePosted!: Date;
    ref!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.details = _data["details"];
            this.requirements = _data["requirements"];
            this.position = _data["position"];
            this.recruiter = _data["recruiter"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.location = _data["location"];
            this.jobTypeId = _data["jobTypeId"];
            this.minExpRequired = _data["minExpRequired"];
            this.maxExpRequired = _data["maxExpRequired"];
            this.minSalary = _data["minSalary"];
            this.maxSalary = _data["maxSalary"];
            this.minQualificationId = _data["minQualificationId"];
            this.maxQualificationId = _data["maxQualificationId"];
            this.quizId = _data["quizId"];
            this.currencyId = _data["currencyId"];
            this.skillAreaId = _data["skillAreaId"];
            this.reviewers = _data["reviewers"];
            this.clicks = _data["clicks"];
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.datePosted = _data["datePosted"] ? new Date(_data["datePosted"].toString()) : <any>undefined;
            this.ref = _data["ref"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Job {
        data = typeof data === 'object' ? data : {};
        let result = new Job();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["details"] = this.details;
        data["requirements"] = this.requirements;
        data["position"] = this.position;
        data["recruiter"] = this.recruiter;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["location"] = this.location;
        data["jobTypeId"] = this.jobTypeId;
        data["minExpRequired"] = this.minExpRequired;
        data["maxExpRequired"] = this.maxExpRequired;
        data["minSalary"] = this.minSalary;
        data["maxSalary"] = this.maxSalary;
        data["minQualificationId"] = this.minQualificationId;
        data["maxQualificationId"] = this.maxQualificationId;
        data["quizId"] = this.quizId;
        data["currencyId"] = this.currencyId;
        data["skillAreaId"] = this.skillAreaId;
        data["reviewers"] = this.reviewers;
        data["clicks"] = this.clicks;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["datePosted"] = this.datePosted ? this.datePosted.toISOString() : <any>undefined;
        data["ref"] = this.ref;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Job {
        const json = this.toJSON();
        let result = new Job();
        result.init(json);
        return result;
    }
}

export interface IJob {
    details: string | undefined;
    requirements: string | undefined;
    position: string | undefined;
    recruiter: string | undefined;
    countryId: number;
    stateId: number;
    location: string | undefined;
    jobTypeId: number;
    minExpRequired: number | undefined;
    maxExpRequired: number | undefined;
    minSalary: number | undefined;
    maxSalary: number | undefined;
    minQualificationId: number | undefined;
    maxQualificationId: number | undefined;
    quizId: number | undefined;
    currencyId: number | undefined;
    skillAreaId: number;
    reviewers: string | undefined;
    clicks: number;
    endDate: Date;
    datePosted: Date;
    ref: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class RecruitmentStage implements IRecruitmentStage {
    id!: number;
    rank!: number;
    name!: string | undefined;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRecruitmentStage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rank = _data["rank"];
            this.name = _data["name"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): RecruitmentStage {
        data = typeof data === 'object' ? data : {};
        let result = new RecruitmentStage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rank"] = this.rank;
        data["name"] = this.name;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): RecruitmentStage {
        const json = this.toJSON();
        let result = new RecruitmentStage();
        result.init(json);
        return result;
    }
}

export interface IRecruitmentStage {
    id: number;
    rank: number;
    name: string | undefined;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class AppliedApplicant implements IAppliedApplicant {
    jobId!: number;
    applicantCode!: string | undefined;
    registeredUserId!: number;
    dateApplied!: Date;
    lastUpdate!: Date | undefined;
    alertSent!: boolean;
    coverLetter!: string | undefined;
    jobLocation!: number | undefined;
    recruitmentStageId!: number | undefined;
    testPassCode!: string | undefined;
    job!: Job;
    recruitmentStage!: RecruitmentStage;
    registeredUser!: RegisteredUser;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IAppliedApplicant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
            this.applicantCode = _data["applicantCode"];
            this.registeredUserId = _data["registeredUserId"];
            this.dateApplied = _data["dateApplied"] ? new Date(_data["dateApplied"].toString()) : <any>undefined;
            this.lastUpdate = _data["lastUpdate"] ? new Date(_data["lastUpdate"].toString()) : <any>undefined;
            this.alertSent = _data["alertSent"];
            this.coverLetter = _data["coverLetter"];
            this.jobLocation = _data["jobLocation"];
            this.recruitmentStageId = _data["recruitmentStageId"];
            this.testPassCode = _data["testPassCode"];
            this.job = _data["job"] ? Job.fromJS(_data["job"]) : <any>undefined;
            this.recruitmentStage = _data["recruitmentStage"] ? RecruitmentStage.fromJS(_data["recruitmentStage"]) : <any>undefined;
            this.registeredUser = _data["registeredUser"] ? RegisteredUser.fromJS(_data["registeredUser"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): AppliedApplicant {
        data = typeof data === 'object' ? data : {};
        let result = new AppliedApplicant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["applicantCode"] = this.applicantCode;
        data["registeredUserId"] = this.registeredUserId;
        data["dateApplied"] = this.dateApplied ? this.dateApplied.toISOString() : <any>undefined;
        data["lastUpdate"] = this.lastUpdate ? this.lastUpdate.toISOString() : <any>undefined;
        data["alertSent"] = this.alertSent;
        data["coverLetter"] = this.coverLetter;
        data["jobLocation"] = this.jobLocation;
        data["recruitmentStageId"] = this.recruitmentStageId;
        data["testPassCode"] = this.testPassCode;
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        data["recruitmentStage"] = this.recruitmentStage ? this.recruitmentStage.toJSON() : <any>undefined;
        data["registeredUser"] = this.registeredUser ? this.registeredUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): AppliedApplicant {
        const json = this.toJSON();
        let result = new AppliedApplicant();
        result.init(json);
        return result;
    }
}

export interface IAppliedApplicant {
    jobId: number;
    applicantCode: string | undefined;
    registeredUserId: number;
    dateApplied: Date;
    lastUpdate: Date | undefined;
    alertSent: boolean;
    coverLetter: string | undefined;
    jobLocation: number | undefined;
    recruitmentStageId: number | undefined;
    testPassCode: string | undefined;
    job: Job;
    recruitmentStage: RecruitmentStage;
    registeredUser: RegisteredUser;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class JobCourse implements IJobCourse {
    courseId!: number;
    jobId!: number;
    course!: Course;
    job!: Job;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IJobCourse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.courseId = _data["courseId"];
            this.jobId = _data["jobId"];
            this.course = _data["course"] ? Course.fromJS(_data["course"]) : <any>undefined;
            this.job = _data["job"] ? Job.fromJS(_data["job"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): JobCourse {
        data = typeof data === 'object' ? data : {};
        let result = new JobCourse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["courseId"] = this.courseId;
        data["jobId"] = this.jobId;
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): JobCourse {
        const json = this.toJSON();
        let result = new JobCourse();
        result.init(json);
        return result;
    }
}

export interface IJobCourse {
    courseId: number;
    jobId: number;
    course: Course;
    job: Job;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Course implements ICourse {
    name!: string | undefined;
    jobCourses!: JobCourse[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICourse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["jobCourses"])) {
                this.jobCourses = [] as any;
                for (let item of _data["jobCourses"])
                    this.jobCourses!.push(JobCourse.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Course {
        data = typeof data === 'object' ? data : {};
        let result = new Course();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.jobCourses)) {
            data["jobCourses"] = [];
            for (let item of this.jobCourses)
                data["jobCourses"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Course {
        const json = this.toJSON();
        let result = new Course();
        result.init(json);
        return result;
    }
}

export interface ICourse {
    name: string | undefined;
    jobCourses: JobCourse[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Qualification implements IQualification {
    categoryId!: number;
    name!: string | undefined;
    code!: string | undefined;
    point!: number | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IQualification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.point = _data["point"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Qualification {
        data = typeof data === 'object' ? data : {};
        let result = new Qualification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["point"] = this.point;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Qualification {
        const json = this.toJSON();
        let result = new Qualification();
        result.init(json);
        return result;
    }
}

export interface IQualification {
    categoryId: number;
    name: string | undefined;
    code: string | undefined;
    point: number | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Institution implements IInstitution {
    name!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IInstitution) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Institution {
        data = typeof data === 'object' ? data : {};
        let result = new Institution();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Institution {
        const json = this.toJSON();
        let result = new Institution();
        result.init(json);
        return result;
    }
}

export interface IInstitution {
    name: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Education implements IEducation {
    registeredUserId!: number;
    qualificationId!: number | undefined;
    disciplineId!: number | undefined;
    startDate!: Date;
    endDate!: Date;
    gradeId!: number | undefined;
    institutionId!: number | undefined;
    institutionName!: string | undefined;
    courseId!: number | undefined;
    course!: Course;
    qualification!: Qualification;
    institution!: Institution;
    registeredUser!: RegisteredUser;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEducation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registeredUserId = _data["registeredUserId"];
            this.qualificationId = _data["qualificationId"];
            this.disciplineId = _data["disciplineId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.gradeId = _data["gradeId"];
            this.institutionId = _data["institutionId"];
            this.institutionName = _data["institutionName"];
            this.courseId = _data["courseId"];
            this.course = _data["course"] ? Course.fromJS(_data["course"]) : <any>undefined;
            this.qualification = _data["qualification"] ? Qualification.fromJS(_data["qualification"]) : <any>undefined;
            this.institution = _data["institution"] ? Institution.fromJS(_data["institution"]) : <any>undefined;
            this.registeredUser = _data["registeredUser"] ? RegisteredUser.fromJS(_data["registeredUser"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Education {
        data = typeof data === 'object' ? data : {};
        let result = new Education();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registeredUserId"] = this.registeredUserId;
        data["qualificationId"] = this.qualificationId;
        data["disciplineId"] = this.disciplineId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["gradeId"] = this.gradeId;
        data["institutionId"] = this.institutionId;
        data["institutionName"] = this.institutionName;
        data["courseId"] = this.courseId;
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        data["qualification"] = this.qualification ? this.qualification.toJSON() : <any>undefined;
        data["institution"] = this.institution ? this.institution.toJSON() : <any>undefined;
        data["registeredUser"] = this.registeredUser ? this.registeredUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Education {
        const json = this.toJSON();
        let result = new Education();
        result.init(json);
        return result;
    }
}

export interface IEducation {
    registeredUserId: number;
    qualificationId: number | undefined;
    disciplineId: number | undefined;
    startDate: Date;
    endDate: Date;
    gradeId: number | undefined;
    institutionId: number | undefined;
    institutionName: string | undefined;
    courseId: number | undefined;
    course: Course;
    qualification: Qualification;
    institution: Institution;
    registeredUser: RegisteredUser;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Company implements ICompany {
    id!: number;
    name!: string | undefined;
    contactPerson!: string | undefined;
    email!: string | undefined;
    mobile!: string | undefined;
    nowRecruiting!: boolean;
    registered!: boolean;
    sectorId!: number;
    logo!: string | undefined;
    employerTypeId!: number | undefined;
    accountTypeId!: number;
    isPlanActivated!: boolean;
    isTrial!: boolean;
    subscriptionPlanId!: number | undefined;
    lastBillingDate!: Date | undefined;
    lastPaymentDate!: Date | undefined;
    trialDueDate!: Date | undefined;
    licenseUsage!: number;
    code!: string | undefined;
    modified!: Date | undefined;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    jobs!: Job[] | undefined;

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.contactPerson = _data["contactPerson"];
            this.email = _data["email"];
            this.mobile = _data["mobile"];
            this.nowRecruiting = _data["nowRecruiting"];
            this.registered = _data["registered"];
            this.sectorId = _data["sectorId"];
            this.logo = _data["logo"];
            this.employerTypeId = _data["employerTypeId"];
            this.accountTypeId = _data["accountTypeId"];
            this.isPlanActivated = _data["isPlanActivated"];
            this.isTrial = _data["isTrial"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.lastBillingDate = _data["lastBillingDate"] ? new Date(_data["lastBillingDate"].toString()) : <any>undefined;
            this.lastPaymentDate = _data["lastPaymentDate"] ? new Date(_data["lastPaymentDate"].toString()) : <any>undefined;
            this.trialDueDate = _data["trialDueDate"] ? new Date(_data["trialDueDate"].toString()) : <any>undefined;
            this.licenseUsage = _data["licenseUsage"];
            this.code = _data["code"];
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["jobs"])) {
                this.jobs = [] as any;
                for (let item of _data["jobs"])
                    this.jobs!.push(Job.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["contactPerson"] = this.contactPerson;
        data["email"] = this.email;
        data["mobile"] = this.mobile;
        data["nowRecruiting"] = this.nowRecruiting;
        data["registered"] = this.registered;
        data["sectorId"] = this.sectorId;
        data["logo"] = this.logo;
        data["employerTypeId"] = this.employerTypeId;
        data["accountTypeId"] = this.accountTypeId;
        data["isPlanActivated"] = this.isPlanActivated;
        data["isTrial"] = this.isTrial;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["lastBillingDate"] = this.lastBillingDate ? this.lastBillingDate.toISOString() : <any>undefined;
        data["lastPaymentDate"] = this.lastPaymentDate ? this.lastPaymentDate.toISOString() : <any>undefined;
        data["trialDueDate"] = this.trialDueDate ? this.trialDueDate.toISOString() : <any>undefined;
        data["licenseUsage"] = this.licenseUsage;
        data["code"] = this.code;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.jobs)) {
            data["jobs"] = [];
            for (let item of this.jobs)
                data["jobs"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Company {
        const json = this.toJSON();
        let result = new Company();
        result.init(json);
        return result;
    }
}

export interface ICompany {
    id: number;
    name: string | undefined;
    contactPerson: string | undefined;
    email: string | undefined;
    mobile: string | undefined;
    nowRecruiting: boolean;
    registered: boolean;
    sectorId: number;
    logo: string | undefined;
    employerTypeId: number | undefined;
    accountTypeId: number;
    isPlanActivated: boolean;
    isTrial: boolean;
    subscriptionPlanId: number | undefined;
    lastBillingDate: Date | undefined;
    lastPaymentDate: Date | undefined;
    trialDueDate: Date | undefined;
    licenseUsage: number;
    code: string | undefined;
    modified: Date | undefined;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    jobs: Job[] | undefined;
}

export class CompanyGroup implements ICompanyGroup {
    id!: number;
    name!: string | undefined;
    company!: Company;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICompanyGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): CompanyGroup {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): CompanyGroup {
        const json = this.toJSON();
        let result = new CompanyGroup();
        result.init(json);
        return result;
    }
}

export interface ICompanyGroup {
    id: number;
    name: string | undefined;
    company: Company;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class GroupApplicant implements IGroupApplicant {
    registeredUserId!: number;
    companyGroupId!: number;
    companyGroup!: CompanyGroup;
    registeredUser!: RegisteredUser;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IGroupApplicant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registeredUserId = _data["registeredUserId"];
            this.companyGroupId = _data["companyGroupId"];
            this.companyGroup = _data["companyGroup"] ? CompanyGroup.fromJS(_data["companyGroup"]) : <any>undefined;
            this.registeredUser = _data["registeredUser"] ? RegisteredUser.fromJS(_data["registeredUser"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): GroupApplicant {
        data = typeof data === 'object' ? data : {};
        let result = new GroupApplicant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registeredUserId"] = this.registeredUserId;
        data["companyGroupId"] = this.companyGroupId;
        data["companyGroup"] = this.companyGroup ? this.companyGroup.toJSON() : <any>undefined;
        data["registeredUser"] = this.registeredUser ? this.registeredUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): GroupApplicant {
        const json = this.toJSON();
        let result = new GroupApplicant();
        result.init(json);
        return result;
    }
}

export interface IGroupApplicant {
    registeredUserId: number;
    companyGroupId: number;
    companyGroup: CompanyGroup;
    registeredUser: RegisteredUser;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ProfessionalBody implements IProfessionalBody {
    sectorId!: number;
    name!: string | undefined;
    code!: string | undefined;
    website!: string | undefined;
    certifications!: Certification[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IProfessionalBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sectorId = _data["sectorId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.website = _data["website"];
            if (Array.isArray(_data["certifications"])) {
                this.certifications = [] as any;
                for (let item of _data["certifications"])
                    this.certifications!.push(Certification.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ProfessionalBody {
        data = typeof data === 'object' ? data : {};
        let result = new ProfessionalBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sectorId"] = this.sectorId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["website"] = this.website;
        if (Array.isArray(this.certifications)) {
            data["certifications"] = [];
            for (let item of this.certifications)
                data["certifications"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ProfessionalBody {
        const json = this.toJSON();
        let result = new ProfessionalBody();
        result.init(json);
        return result;
    }
}

export interface IProfessionalBody {
    sectorId: number;
    name: string | undefined;
    code: string | undefined;
    website: string | undefined;
    certifications: Certification[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ApplicantCertification implements IApplicantCertification {
    registeredUserId!: number;
    year!: number;
    certificationId!: number;
    certificationName!: string | undefined;
    certification!: Certification;
    registeredUser!: RegisteredUser;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IApplicantCertification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registeredUserId = _data["registeredUserId"];
            this.year = _data["year"];
            this.certificationId = _data["certificationId"];
            this.certificationName = _data["certificationName"];
            this.certification = _data["certification"] ? Certification.fromJS(_data["certification"]) : <any>undefined;
            this.registeredUser = _data["registeredUser"] ? RegisteredUser.fromJS(_data["registeredUser"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ApplicantCertification {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicantCertification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registeredUserId"] = this.registeredUserId;
        data["year"] = this.year;
        data["certificationId"] = this.certificationId;
        data["certificationName"] = this.certificationName;
        data["certification"] = this.certification ? this.certification.toJSON() : <any>undefined;
        data["registeredUser"] = this.registeredUser ? this.registeredUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ApplicantCertification {
        const json = this.toJSON();
        let result = new ApplicantCertification();
        result.init(json);
        return result;
    }
}

export interface IApplicantCertification {
    registeredUserId: number;
    year: number;
    certificationId: number;
    certificationName: string | undefined;
    certification: Certification;
    registeredUser: RegisteredUser;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Certification implements ICertification {
    professionalBodyId!: number;
    name!: string | undefined;
    code!: string | undefined;
    point!: number | undefined;
    professionalBody!: ProfessionalBody;
    applicantCertifications!: ApplicantCertification[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICertification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.professionalBodyId = _data["professionalBodyId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.point = _data["point"];
            this.professionalBody = _data["professionalBody"] ? ProfessionalBody.fromJS(_data["professionalBody"]) : <any>undefined;
            if (Array.isArray(_data["applicantCertifications"])) {
                this.applicantCertifications = [] as any;
                for (let item of _data["applicantCertifications"])
                    this.applicantCertifications!.push(ApplicantCertification.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Certification {
        data = typeof data === 'object' ? data : {};
        let result = new Certification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["professionalBodyId"] = this.professionalBodyId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["point"] = this.point;
        data["professionalBody"] = this.professionalBody ? this.professionalBody.toJSON() : <any>undefined;
        if (Array.isArray(this.applicantCertifications)) {
            data["applicantCertifications"] = [];
            for (let item of this.applicantCertifications)
                data["applicantCertifications"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Certification {
        const json = this.toJSON();
        let result = new Certification();
        result.init(json);
        return result;
    }
}

export interface ICertification {
    professionalBodyId: number;
    name: string | undefined;
    code: string | undefined;
    point: number | undefined;
    professionalBody: ProfessionalBody;
    applicantCertifications: ApplicantCertification[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class CoverLetter implements ICoverLetter {
    registeredUserId!: number;
    name!: string | undefined;
    content!: string | undefined;
    registeredUser!: RegisteredUser;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICoverLetter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registeredUserId = _data["registeredUserId"];
            this.name = _data["name"];
            this.content = _data["content"];
            this.registeredUser = _data["registeredUser"] ? RegisteredUser.fromJS(_data["registeredUser"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): CoverLetter {
        data = typeof data === 'object' ? data : {};
        let result = new CoverLetter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registeredUserId"] = this.registeredUserId;
        data["name"] = this.name;
        data["content"] = this.content;
        data["registeredUser"] = this.registeredUser ? this.registeredUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): CoverLetter {
        const json = this.toJSON();
        let result = new CoverLetter();
        result.init(json);
        return result;
    }
}

export interface ICoverLetter {
    registeredUserId: number;
    name: string | undefined;
    content: string | undefined;
    registeredUser: RegisteredUser;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class SkillArea implements ISkillArea {
    name!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ISkillArea) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): SkillArea {
        data = typeof data === 'object' ? data : {};
        let result = new SkillArea();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): SkillArea {
        const json = this.toJSON();
        let result = new SkillArea();
        result.init(json);
        return result;
    }
}

export interface ISkillArea {
    name: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class DesiredFunctionalArea implements IDesiredFunctionalArea {
    registeredUserId!: number;
    skillAreaId!: number;
    registeredUser!: RegisteredUser;
    skillArea!: SkillArea;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDesiredFunctionalArea) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registeredUserId = _data["registeredUserId"];
            this.skillAreaId = _data["skillAreaId"];
            this.registeredUser = _data["registeredUser"] ? RegisteredUser.fromJS(_data["registeredUser"]) : <any>undefined;
            this.skillArea = _data["skillArea"] ? SkillArea.fromJS(_data["skillArea"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): DesiredFunctionalArea {
        data = typeof data === 'object' ? data : {};
        let result = new DesiredFunctionalArea();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registeredUserId"] = this.registeredUserId;
        data["skillAreaId"] = this.skillAreaId;
        data["registeredUser"] = this.registeredUser ? this.registeredUser.toJSON() : <any>undefined;
        data["skillArea"] = this.skillArea ? this.skillArea.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): DesiredFunctionalArea {
        const json = this.toJSON();
        let result = new DesiredFunctionalArea();
        result.init(json);
        return result;
    }
}

export interface IDesiredFunctionalArea {
    registeredUserId: number;
    skillAreaId: number;
    registeredUser: RegisteredUser;
    skillArea: SkillArea;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class State implements IState {
    name!: string | undefined;
    visibleToJobSeekers!: boolean | undefined;
    countryId!: number | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.visibleToJobSeekers = _data["visibleToJobSeekers"];
            this.countryId = _data["countryId"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): State {
        data = typeof data === 'object' ? data : {};
        let result = new State();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["visibleToJobSeekers"] = this.visibleToJobSeekers;
        data["countryId"] = this.countryId;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): State {
        const json = this.toJSON();
        let result = new State();
        result.init(json);
        return result;
    }
}

export interface IState {
    name: string | undefined;
    visibleToJobSeekers: boolean | undefined;
    countryId: number | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class DesiredJobLocation implements IDesiredJobLocation {
    registeredUserId!: number;
    stateId!: number;
    registeredUser!: RegisteredUser;
    state!: State;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDesiredJobLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registeredUserId = _data["registeredUserId"];
            this.stateId = _data["stateId"];
            this.registeredUser = _data["registeredUser"] ? RegisteredUser.fromJS(_data["registeredUser"]) : <any>undefined;
            this.state = _data["state"] ? State.fromJS(_data["state"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): DesiredJobLocation {
        data = typeof data === 'object' ? data : {};
        let result = new DesiredJobLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registeredUserId"] = this.registeredUserId;
        data["stateId"] = this.stateId;
        data["registeredUser"] = this.registeredUser ? this.registeredUser.toJSON() : <any>undefined;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): DesiredJobLocation {
        const json = this.toJSON();
        let result = new DesiredJobLocation();
        result.init(json);
        return result;
    }
}

export interface IDesiredJobLocation {
    registeredUserId: number;
    stateId: number;
    registeredUser: RegisteredUser;
    state: State;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class JobType implements IJobType {
    id!: number;
    name!: string | undefined;
    dateCreated!: Date;
    modified!: Date | undefined;
    isDeleted!: boolean;
    isActive!: boolean;
    jobs!: Job[] | undefined;

    constructor(data?: IJobType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["jobs"])) {
                this.jobs = [] as any;
                for (let item of _data["jobs"])
                    this.jobs!.push(Job.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JobType {
        data = typeof data === 'object' ? data : {};
        let result = new JobType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.jobs)) {
            data["jobs"] = [];
            for (let item of this.jobs)
                data["jobs"].push(item.toJSON());
        }
        return data; 
    }

    clone(): JobType {
        const json = this.toJSON();
        let result = new JobType();
        result.init(json);
        return result;
    }
}

export interface IJobType {
    id: number;
    name: string | undefined;
    dateCreated: Date;
    modified: Date | undefined;
    isDeleted: boolean;
    isActive: boolean;
    jobs: Job[] | undefined;
}

export class DesiredJobType implements IDesiredJobType {
    registeredUserId!: number;
    jobTypeId!: number;
    jobType!: JobType;
    registeredUser!: RegisteredUser;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDesiredJobType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registeredUserId = _data["registeredUserId"];
            this.jobTypeId = _data["jobTypeId"];
            this.jobType = _data["jobType"] ? JobType.fromJS(_data["jobType"]) : <any>undefined;
            this.registeredUser = _data["registeredUser"] ? RegisteredUser.fromJS(_data["registeredUser"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): DesiredJobType {
        data = typeof data === 'object' ? data : {};
        let result = new DesiredJobType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registeredUserId"] = this.registeredUserId;
        data["jobTypeId"] = this.jobTypeId;
        data["jobType"] = this.jobType ? this.jobType.toJSON() : <any>undefined;
        data["registeredUser"] = this.registeredUser ? this.registeredUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): DesiredJobType {
        const json = this.toJSON();
        let result = new DesiredJobType();
        result.init(json);
        return result;
    }
}

export interface IDesiredJobType {
    registeredUserId: number;
    jobTypeId: number;
    jobType: JobType;
    registeredUser: RegisteredUser;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class VisibilityMode implements IVisibilityMode {
    id!: number;
    name!: string | undefined;
    registeredUsers!: RegisteredUser[] | undefined;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IVisibilityMode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["registeredUsers"])) {
                this.registeredUsers = [] as any;
                for (let item of _data["registeredUsers"])
                    this.registeredUsers!.push(RegisteredUser.fromJS(item));
            }
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): VisibilityMode {
        data = typeof data === 'object' ? data : {};
        let result = new VisibilityMode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.registeredUsers)) {
            data["registeredUsers"] = [];
            for (let item of this.registeredUsers)
                data["registeredUsers"].push(item.toJSON());
        }
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): VisibilityMode {
        const json = this.toJSON();
        let result = new VisibilityMode();
        result.init(json);
        return result;
    }
}

export interface IVisibilityMode {
    id: number;
    name: string | undefined;
    registeredUsers: RegisteredUser[] | undefined;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class WarehouseSection implements IWarehouseSection {
    name!: string | undefined;
    description!: string | undefined;
    company!: Company;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IWarehouseSection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): WarehouseSection {
        data = typeof data === 'object' ? data : {};
        let result = new WarehouseSection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): WarehouseSection {
        const json = this.toJSON();
        let result = new WarehouseSection();
        result.init(json);
        return result;
    }
}

export interface IWarehouseSection {
    name: string | undefined;
    description: string | undefined;
    company: Company;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class UserWarehouseSection implements IUserWarehouseSection {
    registeredUserId!: number;
    warehouseSectionId!: number;
    registeredUser!: RegisteredUser;
    warehouseSection!: WarehouseSection;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IUserWarehouseSection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registeredUserId = _data["registeredUserId"];
            this.warehouseSectionId = _data["warehouseSectionId"];
            this.registeredUser = _data["registeredUser"] ? RegisteredUser.fromJS(_data["registeredUser"]) : <any>undefined;
            this.warehouseSection = _data["warehouseSection"] ? WarehouseSection.fromJS(_data["warehouseSection"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): UserWarehouseSection {
        data = typeof data === 'object' ? data : {};
        let result = new UserWarehouseSection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registeredUserId"] = this.registeredUserId;
        data["warehouseSectionId"] = this.warehouseSectionId;
        data["registeredUser"] = this.registeredUser ? this.registeredUser.toJSON() : <any>undefined;
        data["warehouseSection"] = this.warehouseSection ? this.warehouseSection.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): UserWarehouseSection {
        const json = this.toJSON();
        let result = new UserWarehouseSection();
        result.init(json);
        return result;
    }
}

export interface IUserWarehouseSection {
    registeredUserId: number;
    warehouseSectionId: number;
    registeredUser: RegisteredUser;
    warehouseSection: WarehouseSection;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class WorkExprience implements IWorkExprience {
    jobDescription!: string | undefined;
    startDate!: Date;
    from!: number | undefined;
    to!: number | undefined;
    registeredUserId!: number;
    position!: string | undefined;
    skillAreaId!: number | undefined;
    company!: string | undefined;
    sectorId!: number | undefined;
    isPresentEmployment!: boolean | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IWorkExprience) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobDescription = _data["jobDescription"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.from = _data["from"];
            this.to = _data["to"];
            this.registeredUserId = _data["registeredUserId"];
            this.position = _data["position"];
            this.skillAreaId = _data["skillAreaId"];
            this.company = _data["company"];
            this.sectorId = _data["sectorId"];
            this.isPresentEmployment = _data["isPresentEmployment"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): WorkExprience {
        data = typeof data === 'object' ? data : {};
        let result = new WorkExprience();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobDescription"] = this.jobDescription;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["from"] = this.from;
        data["to"] = this.to;
        data["registeredUserId"] = this.registeredUserId;
        data["position"] = this.position;
        data["skillAreaId"] = this.skillAreaId;
        data["company"] = this.company;
        data["sectorId"] = this.sectorId;
        data["isPresentEmployment"] = this.isPresentEmployment;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): WorkExprience {
        const json = this.toJSON();
        let result = new WorkExprience();
        result.init(json);
        return result;
    }
}

export interface IWorkExprience {
    jobDescription: string | undefined;
    startDate: Date;
    from: number | undefined;
    to: number | undefined;
    registeredUserId: number;
    position: string | undefined;
    skillAreaId: number | undefined;
    company: string | undefined;
    sectorId: number | undefined;
    isPresentEmployment: boolean | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class RegisteredUser implements IRegisteredUser {
    isSocialUser!: boolean;
    titleId!: number | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    otherName!: string | undefined;
    email!: string | undefined;
    mobile!: string | undefined;
    birthDate!: Date | undefined;
    stateOfResidentId!: number | undefined;
    stateOfInterestId!: number | undefined;
    nationalityId!: number | undefined;
    yearOfExperience!: number | undefined;
    gender!: number | undefined;
    sex!: string | undefined;
    title!: string | undefined;
    userId!: number;
    age!: number | undefined;
    applicantType!: number;
    countryId!: number | undefined;
    skills!: string | undefined;
    educationId!: number | undefined;
    lastUpdate!: Date | undefined;
    password!: string | undefined;
    nyscStatus!: number | undefined;
    activated!: Date | undefined;
    workAchievements!: string | undefined;
    cvName!: string | undefined;
    cvMimeType!: string | undefined;
    alertModeId!: number | undefined;
    desiredSalaryCurrency!: string | undefined;
    desiredSalaryAnnum!: number | undefined;
    desiredSalaryNegotiable!: number | undefined;
    willingToRelocate!: number | undefined;
    photoName!: string | undefined;
    videoUrl!: string | undefined;
    youtubeVideoUrl!: string | undefined;
    photoMimeType!: string | undefined;
    visibilityModeId!: number | undefined;
    activationCode!: string | undefined;
    jobMatchAlertId!: number | undefined;
    considerExpForJobAlert!: boolean | undefined;
    completeProfile!: boolean | undefined;
    minJobExpForAlert!: number | undefined;
    alertmode!: Alertmode;
    appliedApplicants!: AppliedApplicant[] | undefined;
    country!: Country;
    educations!: Education[] | undefined;
    groupApplicants!: GroupApplicant[] | undefined;
    certifications!: Certification[] | undefined;
    coverLetters!: CoverLetter[] | undefined;
    desiredFunctionalAreas!: DesiredFunctionalArea[] | undefined;
    desiredJobLocations!: DesiredJobLocation[] | undefined;
    desiredJobTypes!: DesiredJobType[] | undefined;
    visibilityMode!: VisibilityMode;
    userWarehouseSections!: UserWarehouseSection[] | undefined;
    workExpriences!: WorkExprience[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRegisteredUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSocialUser = _data["isSocialUser"];
            this.titleId = _data["titleId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.otherName = _data["otherName"];
            this.email = _data["email"];
            this.mobile = _data["mobile"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.stateOfResidentId = _data["stateOfResidentId"];
            this.stateOfInterestId = _data["stateOfInterestId"];
            this.nationalityId = _data["nationalityId"];
            this.yearOfExperience = _data["yearOfExperience"];
            this.gender = _data["gender"];
            this.sex = _data["sex"];
            this.title = _data["title"];
            this.userId = _data["userId"];
            this.age = _data["age"];
            this.applicantType = _data["applicantType"];
            this.countryId = _data["countryId"];
            this.skills = _data["skills"];
            this.educationId = _data["educationId"];
            this.lastUpdate = _data["lastUpdate"] ? new Date(_data["lastUpdate"].toString()) : <any>undefined;
            this.password = _data["password"];
            this.nyscStatus = _data["nyscStatus"];
            this.activated = _data["activated"] ? new Date(_data["activated"].toString()) : <any>undefined;
            this.workAchievements = _data["workAchievements"];
            this.cvName = _data["cvName"];
            this.cvMimeType = _data["cvMimeType"];
            this.alertModeId = _data["alertModeId"];
            this.desiredSalaryCurrency = _data["desiredSalaryCurrency"];
            this.desiredSalaryAnnum = _data["desiredSalaryAnnum"];
            this.desiredSalaryNegotiable = _data["desiredSalaryNegotiable"];
            this.willingToRelocate = _data["willingToRelocate"];
            this.photoName = _data["photoName"];
            this.videoUrl = _data["videoUrl"];
            this.youtubeVideoUrl = _data["youtubeVideoUrl"];
            this.photoMimeType = _data["photoMimeType"];
            this.visibilityModeId = _data["visibilityModeId"];
            this.activationCode = _data["activationCode"];
            this.jobMatchAlertId = _data["jobMatchAlertId"];
            this.considerExpForJobAlert = _data["considerExpForJobAlert"];
            this.completeProfile = _data["completeProfile"];
            this.minJobExpForAlert = _data["minJobExpForAlert"];
            this.alertmode = _data["alertmode"] ? Alertmode.fromJS(_data["alertmode"]) : <any>undefined;
            if (Array.isArray(_data["appliedApplicants"])) {
                this.appliedApplicants = [] as any;
                for (let item of _data["appliedApplicants"])
                    this.appliedApplicants!.push(AppliedApplicant.fromJS(item));
            }
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : <any>undefined;
            if (Array.isArray(_data["educations"])) {
                this.educations = [] as any;
                for (let item of _data["educations"])
                    this.educations!.push(Education.fromJS(item));
            }
            if (Array.isArray(_data["groupApplicants"])) {
                this.groupApplicants = [] as any;
                for (let item of _data["groupApplicants"])
                    this.groupApplicants!.push(GroupApplicant.fromJS(item));
            }
            if (Array.isArray(_data["certifications"])) {
                this.certifications = [] as any;
                for (let item of _data["certifications"])
                    this.certifications!.push(Certification.fromJS(item));
            }
            if (Array.isArray(_data["coverLetters"])) {
                this.coverLetters = [] as any;
                for (let item of _data["coverLetters"])
                    this.coverLetters!.push(CoverLetter.fromJS(item));
            }
            if (Array.isArray(_data["desiredFunctionalAreas"])) {
                this.desiredFunctionalAreas = [] as any;
                for (let item of _data["desiredFunctionalAreas"])
                    this.desiredFunctionalAreas!.push(DesiredFunctionalArea.fromJS(item));
            }
            if (Array.isArray(_data["desiredJobLocations"])) {
                this.desiredJobLocations = [] as any;
                for (let item of _data["desiredJobLocations"])
                    this.desiredJobLocations!.push(DesiredJobLocation.fromJS(item));
            }
            if (Array.isArray(_data["desiredJobTypes"])) {
                this.desiredJobTypes = [] as any;
                for (let item of _data["desiredJobTypes"])
                    this.desiredJobTypes!.push(DesiredJobType.fromJS(item));
            }
            this.visibilityMode = _data["visibilityMode"] ? VisibilityMode.fromJS(_data["visibilityMode"]) : <any>undefined;
            if (Array.isArray(_data["userWarehouseSections"])) {
                this.userWarehouseSections = [] as any;
                for (let item of _data["userWarehouseSections"])
                    this.userWarehouseSections!.push(UserWarehouseSection.fromJS(item));
            }
            if (Array.isArray(_data["workExpriences"])) {
                this.workExpriences = [] as any;
                for (let item of _data["workExpriences"])
                    this.workExpriences!.push(WorkExprience.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): RegisteredUser {
        data = typeof data === 'object' ? data : {};
        let result = new RegisteredUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSocialUser"] = this.isSocialUser;
        data["titleId"] = this.titleId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["otherName"] = this.otherName;
        data["email"] = this.email;
        data["mobile"] = this.mobile;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["stateOfResidentId"] = this.stateOfResidentId;
        data["stateOfInterestId"] = this.stateOfInterestId;
        data["nationalityId"] = this.nationalityId;
        data["yearOfExperience"] = this.yearOfExperience;
        data["gender"] = this.gender;
        data["sex"] = this.sex;
        data["title"] = this.title;
        data["userId"] = this.userId;
        data["age"] = this.age;
        data["applicantType"] = this.applicantType;
        data["countryId"] = this.countryId;
        data["skills"] = this.skills;
        data["educationId"] = this.educationId;
        data["lastUpdate"] = this.lastUpdate ? this.lastUpdate.toISOString() : <any>undefined;
        data["password"] = this.password;
        data["nyscStatus"] = this.nyscStatus;
        data["activated"] = this.activated ? this.activated.toISOString() : <any>undefined;
        data["workAchievements"] = this.workAchievements;
        data["cvName"] = this.cvName;
        data["cvMimeType"] = this.cvMimeType;
        data["alertModeId"] = this.alertModeId;
        data["desiredSalaryCurrency"] = this.desiredSalaryCurrency;
        data["desiredSalaryAnnum"] = this.desiredSalaryAnnum;
        data["desiredSalaryNegotiable"] = this.desiredSalaryNegotiable;
        data["willingToRelocate"] = this.willingToRelocate;
        data["photoName"] = this.photoName;
        data["videoUrl"] = this.videoUrl;
        data["youtubeVideoUrl"] = this.youtubeVideoUrl;
        data["photoMimeType"] = this.photoMimeType;
        data["visibilityModeId"] = this.visibilityModeId;
        data["activationCode"] = this.activationCode;
        data["jobMatchAlertId"] = this.jobMatchAlertId;
        data["considerExpForJobAlert"] = this.considerExpForJobAlert;
        data["completeProfile"] = this.completeProfile;
        data["minJobExpForAlert"] = this.minJobExpForAlert;
        data["alertmode"] = this.alertmode ? this.alertmode.toJSON() : <any>undefined;
        if (Array.isArray(this.appliedApplicants)) {
            data["appliedApplicants"] = [];
            for (let item of this.appliedApplicants)
                data["appliedApplicants"].push(item.toJSON());
        }
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        if (Array.isArray(this.educations)) {
            data["educations"] = [];
            for (let item of this.educations)
                data["educations"].push(item.toJSON());
        }
        if (Array.isArray(this.groupApplicants)) {
            data["groupApplicants"] = [];
            for (let item of this.groupApplicants)
                data["groupApplicants"].push(item.toJSON());
        }
        if (Array.isArray(this.certifications)) {
            data["certifications"] = [];
            for (let item of this.certifications)
                data["certifications"].push(item.toJSON());
        }
        if (Array.isArray(this.coverLetters)) {
            data["coverLetters"] = [];
            for (let item of this.coverLetters)
                data["coverLetters"].push(item.toJSON());
        }
        if (Array.isArray(this.desiredFunctionalAreas)) {
            data["desiredFunctionalAreas"] = [];
            for (let item of this.desiredFunctionalAreas)
                data["desiredFunctionalAreas"].push(item.toJSON());
        }
        if (Array.isArray(this.desiredJobLocations)) {
            data["desiredJobLocations"] = [];
            for (let item of this.desiredJobLocations)
                data["desiredJobLocations"].push(item.toJSON());
        }
        if (Array.isArray(this.desiredJobTypes)) {
            data["desiredJobTypes"] = [];
            for (let item of this.desiredJobTypes)
                data["desiredJobTypes"].push(item.toJSON());
        }
        data["visibilityMode"] = this.visibilityMode ? this.visibilityMode.toJSON() : <any>undefined;
        if (Array.isArray(this.userWarehouseSections)) {
            data["userWarehouseSections"] = [];
            for (let item of this.userWarehouseSections)
                data["userWarehouseSections"].push(item.toJSON());
        }
        if (Array.isArray(this.workExpriences)) {
            data["workExpriences"] = [];
            for (let item of this.workExpriences)
                data["workExpriences"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): RegisteredUser {
        const json = this.toJSON();
        let result = new RegisteredUser();
        result.init(json);
        return result;
    }
}

export interface IRegisteredUser {
    isSocialUser: boolean;
    titleId: number | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    otherName: string | undefined;
    email: string | undefined;
    mobile: string | undefined;
    birthDate: Date | undefined;
    stateOfResidentId: number | undefined;
    stateOfInterestId: number | undefined;
    nationalityId: number | undefined;
    yearOfExperience: number | undefined;
    gender: number | undefined;
    sex: string | undefined;
    title: string | undefined;
    userId: number;
    age: number | undefined;
    applicantType: number;
    countryId: number | undefined;
    skills: string | undefined;
    educationId: number | undefined;
    lastUpdate: Date | undefined;
    password: string | undefined;
    nyscStatus: number | undefined;
    activated: Date | undefined;
    workAchievements: string | undefined;
    cvName: string | undefined;
    cvMimeType: string | undefined;
    alertModeId: number | undefined;
    desiredSalaryCurrency: string | undefined;
    desiredSalaryAnnum: number | undefined;
    desiredSalaryNegotiable: number | undefined;
    willingToRelocate: number | undefined;
    photoName: string | undefined;
    videoUrl: string | undefined;
    youtubeVideoUrl: string | undefined;
    photoMimeType: string | undefined;
    visibilityModeId: number | undefined;
    activationCode: string | undefined;
    jobMatchAlertId: number | undefined;
    considerExpForJobAlert: boolean | undefined;
    completeProfile: boolean | undefined;
    minJobExpForAlert: number | undefined;
    alertmode: Alertmode;
    appliedApplicants: AppliedApplicant[] | undefined;
    country: Country;
    educations: Education[] | undefined;
    groupApplicants: GroupApplicant[] | undefined;
    certifications: Certification[] | undefined;
    coverLetters: CoverLetter[] | undefined;
    desiredFunctionalAreas: DesiredFunctionalArea[] | undefined;
    desiredJobLocations: DesiredJobLocation[] | undefined;
    desiredJobTypes: DesiredJobType[] | undefined;
    visibilityMode: VisibilityMode;
    userWarehouseSections: UserWarehouseSection[] | undefined;
    workExpriences: WorkExprience[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Country implements ICountry {
    name!: string | undefined;
    code!: string | undefined;
    isDefault!: boolean;
    registeredUsers!: RegisteredUser[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.isDefault = _data["isDefault"];
            if (Array.isArray(_data["registeredUsers"])) {
                this.registeredUsers = [] as any;
                for (let item of _data["registeredUsers"])
                    this.registeredUsers!.push(RegisteredUser.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["isDefault"] = this.isDefault;
        if (Array.isArray(this.registeredUsers)) {
            data["registeredUsers"] = [];
            for (let item of this.registeredUsers)
                data["registeredUsers"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Country {
        const json = this.toJSON();
        let result = new Country();
        result.init(json);
        return result;
    }
}

export interface ICountry {
    name: string | undefined;
    code: string | undefined;
    isDefault: boolean;
    registeredUsers: RegisteredUser[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class CountryIListOdataResult implements ICountryIListOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: Country[] | undefined;

    constructor(data?: ICountryIListOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Country.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CountryIListOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new CountryIListOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CountryIListOdataResult {
        const json = this.toJSON();
        let result = new CountryIListOdataResult();
        result.init(json);
        return result;
    }
}

export interface ICountryIListOdataResult {
    id: number;
    odataContext: string | undefined;
    value: Country[] | undefined;
}

export class IDTextViewModelIListOdataResult implements IIDTextViewModelIListOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: IDTextViewModel[] | undefined;

    constructor(data?: IIDTextViewModelIListOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(IDTextViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IDTextViewModelIListOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new IDTextViewModelIListOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): IDTextViewModelIListOdataResult {
        const json = this.toJSON();
        let result = new IDTextViewModelIListOdataResult();
        result.init(json);
        return result;
    }
}

export interface IIDTextViewModelIListOdataResult {
    id: number;
    odataContext: string | undefined;
    value: IDTextViewModel[] | undefined;
}

export class CourseIListOdataResult implements ICourseIListOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: Course[] | undefined;

    constructor(data?: ICourseIListOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Course.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CourseIListOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new CourseIListOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CourseIListOdataResult {
        const json = this.toJSON();
        let result = new CourseIListOdataResult();
        result.init(json);
        return result;
    }
}

export interface ICourseIListOdataResult {
    id: number;
    odataContext: string | undefined;
    value: Course[] | undefined;
}

export class Currency implements ICurrency {
    name!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICurrency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Currency {
        data = typeof data === 'object' ? data : {};
        let result = new Currency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Currency {
        const json = this.toJSON();
        let result = new Currency();
        result.init(json);
        return result;
    }
}

export interface ICurrency {
    name: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class CurrencyIListOdataResult implements ICurrencyIListOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: Currency[] | undefined;

    constructor(data?: ICurrencyIListOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Currency.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CurrencyIListOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyIListOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CurrencyIListOdataResult {
        const json = this.toJSON();
        let result = new CurrencyIListOdataResult();
        result.init(json);
        return result;
    }
}

export interface ICurrencyIListOdataResult {
    id: number;
    odataContext: string | undefined;
    value: Currency[] | undefined;
}

export class EmployerType implements IEmployerType {
    name!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployerType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmployerType {
        data = typeof data === 'object' ? data : {};
        let result = new EmployerType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmployerType {
        const json = this.toJSON();
        let result = new EmployerType();
        result.init(json);
        return result;
    }
}

export interface IEmployerType {
    name: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployerTypeIListOdataResult implements IEmployerTypeIListOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: EmployerType[] | undefined;

    constructor(data?: IEmployerTypeIListOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(EmployerType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmployerTypeIListOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmployerTypeIListOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EmployerTypeIListOdataResult {
        const json = this.toJSON();
        let result = new EmployerTypeIListOdataResult();
        result.init(json);
        return result;
    }
}

export interface IEmployerTypeIListOdataResult {
    id: number;
    odataContext: string | undefined;
    value: EmployerType[] | undefined;
}

export class Grade implements IGrade {
    name!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IGrade) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Grade {
        data = typeof data === 'object' ? data : {};
        let result = new Grade();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Grade {
        const json = this.toJSON();
        let result = new Grade();
        result.init(json);
        return result;
    }
}

export interface IGrade {
    name: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class GradeIListOdataResult implements IGradeIListOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: Grade[] | undefined;

    constructor(data?: IGradeIListOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Grade.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GradeIListOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new GradeIListOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GradeIListOdataResult {
        const json = this.toJSON();
        let result = new GradeIListOdataResult();
        result.init(json);
        return result;
    }
}

export interface IGradeIListOdataResult {
    id: number;
    odataContext: string | undefined;
    value: Grade[] | undefined;
}

export class InstitutionIListOdataResult implements IInstitutionIListOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: Institution[] | undefined;

    constructor(data?: IInstitutionIListOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Institution.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InstitutionIListOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new InstitutionIListOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): InstitutionIListOdataResult {
        const json = this.toJSON();
        let result = new InstitutionIListOdataResult();
        result.init(json);
        return result;
    }
}

export interface IInstitutionIListOdataResult {
    id: number;
    odataContext: string | undefined;
    value: Institution[] | undefined;
}

export class JobTypeIListOdataResult implements IJobTypeIListOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: JobType[] | undefined;

    constructor(data?: IJobTypeIListOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(JobType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JobTypeIListOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new JobTypeIListOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): JobTypeIListOdataResult {
        const json = this.toJSON();
        let result = new JobTypeIListOdataResult();
        result.init(json);
        return result;
    }
}

export interface IJobTypeIListOdataResult {
    id: number;
    odataContext: string | undefined;
    value: JobType[] | undefined;
}

export class ManageProfessionalBodyDTO implements IManageProfessionalBodyDTO {
    id!: number;
    sectorId!: number;
    name!: string | undefined;
    code!: string | undefined;
    website!: string | undefined;

    constructor(data?: IManageProfessionalBodyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sectorId = _data["sectorId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.website = _data["website"];
        }
    }

    static fromJS(data: any): ManageProfessionalBodyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageProfessionalBodyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sectorId"] = this.sectorId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["website"] = this.website;
        return data; 
    }

    clone(): ManageProfessionalBodyDTO {
        const json = this.toJSON();
        let result = new ManageProfessionalBodyDTO();
        result.init(json);
        return result;
    }
}

export interface IManageProfessionalBodyDTO {
    id: number;
    sectorId: number;
    name: string | undefined;
    code: string | undefined;
    website: string | undefined;
}

export class ProfessionalBodyDTO implements IProfessionalBodyDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    sectorId!: number;
    sector!: string | undefined;
    name!: string | undefined;
    code!: string | undefined;
    website!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IProfessionalBodyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.sectorId = _data["sectorId"];
            this.sector = _data["sector"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.website = _data["website"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ProfessionalBodyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProfessionalBodyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["sectorId"] = this.sectorId;
        data["sector"] = this.sector;
        data["name"] = this.name;
        data["code"] = this.code;
        data["website"] = this.website;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ProfessionalBodyDTO {
        const json = this.toJSON();
        let result = new ProfessionalBodyDTO();
        result.init(json);
        return result;
    }
}

export interface IProfessionalBodyDTO {
    id: number;
    companyID: number;
    subID: number;
    sectorId: number;
    sector: string | undefined;
    name: string | undefined;
    code: string | undefined;
    website: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ProfessionalBodyDTOListApiResult implements IProfessionalBodyDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ProfessionalBodyDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IProfessionalBodyDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ProfessionalBodyDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ProfessionalBodyDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProfessionalBodyDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ProfessionalBodyDTOListApiResult {
        const json = this.toJSON();
        let result = new ProfessionalBodyDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IProfessionalBodyDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ProfessionalBodyDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ProfessionalBodyDTOApiResult implements IProfessionalBodyDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ProfessionalBodyDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IProfessionalBodyDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? ProfessionalBodyDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ProfessionalBodyDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProfessionalBodyDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ProfessionalBodyDTOApiResult {
        const json = this.toJSON();
        let result = new ProfessionalBodyDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IProfessionalBodyDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ProfessionalBodyDTO;
    totalCount: number;
    totalRecord: number;
}

export class QualificationIListOdataResult implements IQualificationIListOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: Qualification[] | undefined;

    constructor(data?: IQualificationIListOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Qualification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QualificationIListOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new QualificationIListOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): QualificationIListOdataResult {
        const json = this.toJSON();
        let result = new QualificationIListOdataResult();
        result.init(json);
        return result;
    }
}

export interface IQualificationIListOdataResult {
    id: number;
    odataContext: string | undefined;
    value: Qualification[] | undefined;
}

export class ApplicationRoleDTO implements IApplicationRoleDTO {
    id!: number;
    name!: string;
    description!: string | undefined;
    isSystemRole!: boolean;

    constructor(data?: IApplicationRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isSystemRole = _data["isSystemRole"];
        }
    }

    static fromJS(data: any): ApplicationRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isSystemRole"] = this.isSystemRole;
        return data; 
    }

    clone(): ApplicationRoleDTO {
        const json = this.toJSON();
        let result = new ApplicationRoleDTO();
        result.init(json);
        return result;
    }
}

export interface IApplicationRoleDTO {
    id: number;
    name: string;
    description: string | undefined;
    isSystemRole: boolean;
}

export class ApplicationRoleDTOOdataResult implements IApplicationRoleDTOOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: ApplicationRoleDTO;

    constructor(data?: IApplicationRoleDTOOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            this.value = _data["value"] ? ApplicationRoleDTO.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationRoleDTOOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRoleDTOOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ApplicationRoleDTOOdataResult {
        const json = this.toJSON();
        let result = new ApplicationRoleDTOOdataResult();
        result.init(json);
        return result;
    }
}

export interface IApplicationRoleDTOOdataResult {
    id: number;
    odataContext: string | undefined;
    value: ApplicationRoleDTO;
}

export class PermissionDTO implements IPermissionDTO {
    id!: number;
    name!: string | undefined;
    applicationName!: string | undefined;
    code!: string | undefined;

    constructor(data?: IPermissionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.applicationName = _data["applicationName"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): PermissionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["applicationName"] = this.applicationName;
        data["code"] = this.code;
        return data; 
    }

    clone(): PermissionDTO {
        const json = this.toJSON();
        let result = new PermissionDTO();
        result.init(json);
        return result;
    }
}

export interface IPermissionDTO {
    id: number;
    name: string | undefined;
    applicationName: string | undefined;
    code: string | undefined;
}

export class RolePermissionDTO implements IRolePermissionDTO {
    roleId!: number;
    roleName!: string | undefined;
    permissions!: PermissionDTO[] | undefined;

    constructor(data?: IRolePermissionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RolePermissionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RolePermissionDTO {
        const json = this.toJSON();
        let result = new RolePermissionDTO();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionDTO {
    roleId: number;
    roleName: string | undefined;
    permissions: PermissionDTO[] | undefined;
}

export class RolePermissionDTOIListApiResult implements IRolePermissionDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RolePermissionDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRolePermissionDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RolePermissionDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RolePermissionDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RolePermissionDTOIListApiResult {
        const json = this.toJSON();
        let result = new RolePermissionDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RolePermissionDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RolePermissionDTOApiResult implements IRolePermissionDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RolePermissionDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRolePermissionDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? RolePermissionDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RolePermissionDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RolePermissionDTOApiResult {
        const json = this.toJSON();
        let result = new RolePermissionDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RolePermissionDTO;
    totalCount: number;
    totalRecord: number;
}

export class RolePermissionMappingDTO implements IRolePermissionMappingDTO {
    roleId!: number;
    permissionIds!: number[];

    constructor(data?: IRolePermissionMappingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.permissionIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            if (Array.isArray(_data["permissionIds"])) {
                this.permissionIds = [] as any;
                for (let item of _data["permissionIds"])
                    this.permissionIds!.push(item);
            }
        }
    }

    static fromJS(data: any): RolePermissionMappingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionMappingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        if (Array.isArray(this.permissionIds)) {
            data["permissionIds"] = [];
            for (let item of this.permissionIds)
                data["permissionIds"].push(item);
        }
        return data; 
    }

    clone(): RolePermissionMappingDTO {
        const json = this.toJSON();
        let result = new RolePermissionMappingDTO();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionMappingDTO {
    roleId: number;
    permissionIds: number[];
}

export class Sector implements ISector {
    name!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ISector) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Sector {
        data = typeof data === 'object' ? data : {};
        let result = new Sector();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Sector {
        const json = this.toJSON();
        let result = new Sector();
        result.init(json);
        return result;
    }
}

export interface ISector {
    name: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class SectorIListOdataResult implements ISectorIListOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: Sector[] | undefined;

    constructor(data?: ISectorIListOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Sector.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SectorIListOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new SectorIListOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SectorIListOdataResult {
        const json = this.toJSON();
        let result = new SectorIListOdataResult();
        result.init(json);
        return result;
    }
}

export interface ISectorIListOdataResult {
    id: number;
    odataContext: string | undefined;
    value: Sector[] | undefined;
}

export class ManageSkillDTO implements IManageSkillDTO {
    id!: number;
    categoryId!: number;
    category!: string | undefined;
    skills!: string | undefined;

    constructor(data?: IManageSkillDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryId = _data["categoryId"];
            this.category = _data["category"];
            this.skills = _data["skills"];
        }
    }

    static fromJS(data: any): ManageSkillDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageSkillDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category;
        data["skills"] = this.skills;
        return data; 
    }

    clone(): ManageSkillDTO {
        const json = this.toJSON();
        let result = new ManageSkillDTO();
        result.init(json);
        return result;
    }
}

export interface IManageSkillDTO {
    id: number;
    categoryId: number;
    category: string | undefined;
    skills: string | undefined;
}

export class Skill implements ISkill {
    sectorId!: number;
    name!: string | undefined;
    sector!: string | undefined;
    point!: number | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ISkill) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sectorId = _data["sectorId"];
            this.name = _data["name"];
            this.sector = _data["sector"];
            this.point = _data["point"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Skill {
        data = typeof data === 'object' ? data : {};
        let result = new Skill();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sectorId"] = this.sectorId;
        data["name"] = this.name;
        data["sector"] = this.sector;
        data["point"] = this.point;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Skill {
        const json = this.toJSON();
        let result = new Skill();
        result.init(json);
        return result;
    }
}

export interface ISkill {
    sectorId: number;
    name: string | undefined;
    sector: string | undefined;
    point: number | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class SkillListApiResult implements ISkillListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Skill[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ISkillListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Skill.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): SkillListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SkillListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): SkillListApiResult {
        const json = this.toJSON();
        let result = new SkillListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISkillListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Skill[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class SkillApiResult implements ISkillApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Skill;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ISkillApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? Skill.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): SkillApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SkillApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): SkillApiResult {
        const json = this.toJSON();
        let result = new SkillApiResult();
        result.init(json);
        return result;
    }
}

export interface ISkillApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Skill;
    totalCount: number;
    totalRecord: number;
}

export class SkillAreaIListOdataResult implements ISkillAreaIListOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: SkillArea[] | undefined;

    constructor(data?: ISkillAreaIListOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(SkillArea.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SkillAreaIListOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new SkillAreaIListOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SkillAreaIListOdataResult {
        const json = this.toJSON();
        let result = new SkillAreaIListOdataResult();
        result.init(json);
        return result;
    }
}

export interface ISkillAreaIListOdataResult {
    id: number;
    odataContext: string | undefined;
    value: SkillArea[] | undefined;
}

export class StateIListOdataResult implements IStateIListOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: State[] | undefined;

    constructor(data?: IStateIListOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(State.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StateIListOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new StateIListOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StateIListOdataResult {
        const json = this.toJSON();
        let result = new StateIListOdataResult();
        result.init(json);
        return result;
    }
}

export interface IStateIListOdataResult {
    id: number;
    odataContext: string | undefined;
    value: State[] | undefined;
}

export class ClientTempOrder implements IClientTempOrder {
    trasancationEntryId!: number;
    quantity!: number;
    subscriptionId!: number;
    unitCost!: number;
    totalCost!: number;
    temporaryTransactionId!: number | undefined;
    subscription!: Subscription;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IClientTempOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trasancationEntryId = _data["trasancationEntryId"];
            this.quantity = _data["quantity"];
            this.subscriptionId = _data["subscriptionId"];
            this.unitCost = _data["unitCost"];
            this.totalCost = _data["totalCost"];
            this.temporaryTransactionId = _data["temporaryTransactionId"];
            this.subscription = _data["subscription"] ? Subscription.fromJS(_data["subscription"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ClientTempOrder {
        data = typeof data === 'object' ? data : {};
        let result = new ClientTempOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trasancationEntryId"] = this.trasancationEntryId;
        data["quantity"] = this.quantity;
        data["subscriptionId"] = this.subscriptionId;
        data["unitCost"] = this.unitCost;
        data["totalCost"] = this.totalCost;
        data["temporaryTransactionId"] = this.temporaryTransactionId;
        data["subscription"] = this.subscription ? this.subscription.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ClientTempOrder {
        const json = this.toJSON();
        let result = new ClientTempOrder();
        result.init(json);
        return result;
    }
}

export interface IClientTempOrder {
    trasancationEntryId: number;
    quantity: number;
    subscriptionId: number;
    unitCost: number;
    totalCost: number;
    temporaryTransactionId: number | undefined;
    subscription: Subscription;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class PaymentLog implements IPaymentLog {
    id!: number;
    itemId!: number;
    paymentTypeId!: number;
    paymentType!: string | undefined;
    status!: boolean;
    message!: string | undefined;
    amount!: string | undefined;
    currency!: string | undefined;
    transactionDate!: string | undefined;
    reference!: string | undefined;
    plan!: string | undefined;
    domain!: string | undefined;
    channel!: string | undefined;
    ipAddress!: string | undefined;
    authorizationCode!: string | undefined;
    cardType!: string | undefined;
    lastFourDigit!: string | undefined;
    expMonth!: string | undefined;
    expYear!: string | undefined;
    bin!: string | undefined;
    bank!: string | undefined;
    signature!: string | undefined;
    countryCode!: string | undefined;
    accountName!: string | undefined;
    customerId!: string | undefined;
    customerCode!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    email!: string | undefined;
    phone!: string | undefined;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IPaymentLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.itemId = _data["itemId"];
            this.paymentTypeId = _data["paymentTypeId"];
            this.paymentType = _data["paymentType"];
            this.status = _data["status"];
            this.message = _data["message"];
            this.amount = _data["amount"];
            this.currency = _data["currency"];
            this.transactionDate = _data["transactionDate"];
            this.reference = _data["reference"];
            this.plan = _data["plan"];
            this.domain = _data["domain"];
            this.channel = _data["channel"];
            this.ipAddress = _data["ipAddress"];
            this.authorizationCode = _data["authorizationCode"];
            this.cardType = _data["cardType"];
            this.lastFourDigit = _data["lastFourDigit"];
            this.expMonth = _data["expMonth"];
            this.expYear = _data["expYear"];
            this.bin = _data["bin"];
            this.bank = _data["bank"];
            this.signature = _data["signature"];
            this.countryCode = _data["countryCode"];
            this.accountName = _data["accountName"];
            this.customerId = _data["customerId"];
            this.customerCode = _data["customerCode"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PaymentLog {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["itemId"] = this.itemId;
        data["paymentTypeId"] = this.paymentTypeId;
        data["paymentType"] = this.paymentType;
        data["status"] = this.status;
        data["message"] = this.message;
        data["amount"] = this.amount;
        data["currency"] = this.currency;
        data["transactionDate"] = this.transactionDate;
        data["reference"] = this.reference;
        data["plan"] = this.plan;
        data["domain"] = this.domain;
        data["channel"] = this.channel;
        data["ipAddress"] = this.ipAddress;
        data["authorizationCode"] = this.authorizationCode;
        data["cardType"] = this.cardType;
        data["lastFourDigit"] = this.lastFourDigit;
        data["expMonth"] = this.expMonth;
        data["expYear"] = this.expYear;
        data["bin"] = this.bin;
        data["bank"] = this.bank;
        data["signature"] = this.signature;
        data["countryCode"] = this.countryCode;
        data["accountName"] = this.accountName;
        data["customerId"] = this.customerId;
        data["customerCode"] = this.customerCode;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): PaymentLog {
        const json = this.toJSON();
        let result = new PaymentLog();
        result.init(json);
        return result;
    }
}

export interface IPaymentLog {
    id: number;
    itemId: number;
    paymentTypeId: number;
    paymentType: string | undefined;
    status: boolean;
    message: string | undefined;
    amount: string | undefined;
    currency: string | undefined;
    transactionDate: string | undefined;
    reference: string | undefined;
    plan: string | undefined;
    domain: string | undefined;
    channel: string | undefined;
    ipAddress: string | undefined;
    authorizationCode: string | undefined;
    cardType: string | undefined;
    lastFourDigit: string | undefined;
    expMonth: string | undefined;
    expYear: string | undefined;
    bin: string | undefined;
    bank: string | undefined;
    signature: string | undefined;
    countryCode: string | undefined;
    accountName: string | undefined;
    customerId: string | undefined;
    customerCode: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class SubscriptionPayment implements ISubscriptionPayment {
    isPaid!: boolean;
    paymentTypeId!: number;
    paymentType!: string | undefined;
    datePaid!: Date | undefined;
    modified!: Date | undefined;
    subscriptionId!: number;
    transactionReference!: string | undefined;
    quantityPurchased!: number | undefined;
    amountPaid!: number;
    email!: string | undefined;
    paymentLogId!: number;
    paymentById!: number | undefined;
    paymentBy!: string | undefined;
    paymentSource!: number;
    subscription!: Subscription;
    paymentLog!: PaymentLog;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ISubscriptionPayment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isPaid = _data["isPaid"];
            this.paymentTypeId = _data["paymentTypeId"];
            this.paymentType = _data["paymentType"];
            this.datePaid = _data["datePaid"] ? new Date(_data["datePaid"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.subscriptionId = _data["subscriptionId"];
            this.transactionReference = _data["transactionReference"];
            this.quantityPurchased = _data["quantityPurchased"];
            this.amountPaid = _data["amountPaid"];
            this.email = _data["email"];
            this.paymentLogId = _data["paymentLogId"];
            this.paymentById = _data["paymentById"];
            this.paymentBy = _data["paymentBy"];
            this.paymentSource = _data["paymentSource"];
            this.subscription = _data["subscription"] ? Subscription.fromJS(_data["subscription"]) : <any>undefined;
            this.paymentLog = _data["paymentLog"] ? PaymentLog.fromJS(_data["paymentLog"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): SubscriptionPayment {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPayment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isPaid"] = this.isPaid;
        data["paymentTypeId"] = this.paymentTypeId;
        data["paymentType"] = this.paymentType;
        data["datePaid"] = this.datePaid ? this.datePaid.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["subscriptionId"] = this.subscriptionId;
        data["transactionReference"] = this.transactionReference;
        data["quantityPurchased"] = this.quantityPurchased;
        data["amountPaid"] = this.amountPaid;
        data["email"] = this.email;
        data["paymentLogId"] = this.paymentLogId;
        data["paymentById"] = this.paymentById;
        data["paymentBy"] = this.paymentBy;
        data["paymentSource"] = this.paymentSource;
        data["subscription"] = this.subscription ? this.subscription.toJSON() : <any>undefined;
        data["paymentLog"] = this.paymentLog ? this.paymentLog.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): SubscriptionPayment {
        const json = this.toJSON();
        let result = new SubscriptionPayment();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPayment {
    isPaid: boolean;
    paymentTypeId: number;
    paymentType: string | undefined;
    datePaid: Date | undefined;
    modified: Date | undefined;
    subscriptionId: number;
    transactionReference: string | undefined;
    quantityPurchased: number | undefined;
    amountPaid: number;
    email: string | undefined;
    paymentLogId: number;
    paymentById: number | undefined;
    paymentBy: string | undefined;
    paymentSource: number;
    subscription: Subscription;
    paymentLog: PaymentLog;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Subscription implements ISubscription {
    id!: number;
    name!: string | undefined;
    description!: string | undefined;
    features!: string | undefined;
    planCode!: string | undefined;
    licenseCount!: number | undefined;
    typeId!: number;
    amount!: number;
    paymentUrl!: string | undefined;
    canPostJob!: boolean | undefined;
    isRecommended!: boolean | undefined;
    receiveCVAttachment!: boolean | undefined;
    canAccessProfile!: boolean | undefined;
    fullProfileAccess!: boolean | undefined;
    canFilterShortlist!: boolean | undefined;
    canHideIdentity!: boolean | undefined;
    maxQualifiedCandidateForPositionAlert!: number | undefined;
    dateCreated!: Date;
    modified!: Date | undefined;
    isDeleted!: boolean;
    isActive!: boolean;
    clientTempOrders!: ClientTempOrder[] | undefined;
    subscriptionPayments!: SubscriptionPayment[] | undefined;

    constructor(data?: ISubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.features = _data["features"];
            this.planCode = _data["planCode"];
            this.licenseCount = _data["licenseCount"];
            this.typeId = _data["typeId"];
            this.amount = _data["amount"];
            this.paymentUrl = _data["paymentUrl"];
            this.canPostJob = _data["canPostJob"];
            this.isRecommended = _data["isRecommended"];
            this.receiveCVAttachment = _data["receiveCVAttachment"];
            this.canAccessProfile = _data["canAccessProfile"];
            this.fullProfileAccess = _data["fullProfileAccess"];
            this.canFilterShortlist = _data["canFilterShortlist"];
            this.canHideIdentity = _data["canHideIdentity"];
            this.maxQualifiedCandidateForPositionAlert = _data["maxQualifiedCandidateForPositionAlert"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["clientTempOrders"])) {
                this.clientTempOrders = [] as any;
                for (let item of _data["clientTempOrders"])
                    this.clientTempOrders!.push(ClientTempOrder.fromJS(item));
            }
            if (Array.isArray(_data["subscriptionPayments"])) {
                this.subscriptionPayments = [] as any;
                for (let item of _data["subscriptionPayments"])
                    this.subscriptionPayments!.push(SubscriptionPayment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Subscription {
        data = typeof data === 'object' ? data : {};
        let result = new Subscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["features"] = this.features;
        data["planCode"] = this.planCode;
        data["licenseCount"] = this.licenseCount;
        data["typeId"] = this.typeId;
        data["amount"] = this.amount;
        data["paymentUrl"] = this.paymentUrl;
        data["canPostJob"] = this.canPostJob;
        data["isRecommended"] = this.isRecommended;
        data["receiveCVAttachment"] = this.receiveCVAttachment;
        data["canAccessProfile"] = this.canAccessProfile;
        data["fullProfileAccess"] = this.fullProfileAccess;
        data["canFilterShortlist"] = this.canFilterShortlist;
        data["canHideIdentity"] = this.canHideIdentity;
        data["maxQualifiedCandidateForPositionAlert"] = this.maxQualifiedCandidateForPositionAlert;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.clientTempOrders)) {
            data["clientTempOrders"] = [];
            for (let item of this.clientTempOrders)
                data["clientTempOrders"].push(item.toJSON());
        }
        if (Array.isArray(this.subscriptionPayments)) {
            data["subscriptionPayments"] = [];
            for (let item of this.subscriptionPayments)
                data["subscriptionPayments"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Subscription {
        const json = this.toJSON();
        let result = new Subscription();
        result.init(json);
        return result;
    }
}

export interface ISubscription {
    id: number;
    name: string | undefined;
    description: string | undefined;
    features: string | undefined;
    planCode: string | undefined;
    licenseCount: number | undefined;
    typeId: number;
    amount: number;
    paymentUrl: string | undefined;
    canPostJob: boolean | undefined;
    isRecommended: boolean | undefined;
    receiveCVAttachment: boolean | undefined;
    canAccessProfile: boolean | undefined;
    fullProfileAccess: boolean | undefined;
    canFilterShortlist: boolean | undefined;
    canHideIdentity: boolean | undefined;
    maxQualifiedCandidateForPositionAlert: number | undefined;
    dateCreated: Date;
    modified: Date | undefined;
    isDeleted: boolean;
    isActive: boolean;
    clientTempOrders: ClientTempOrder[] | undefined;
    subscriptionPayments: SubscriptionPayment[] | undefined;
}

export class SubscriptionIListOdataResult implements ISubscriptionIListOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: Subscription[] | undefined;

    constructor(data?: ISubscriptionIListOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Subscription.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubscriptionIListOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionIListOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SubscriptionIListOdataResult {
        const json = this.toJSON();
        let result = new SubscriptionIListOdataResult();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionIListOdataResult {
    id: number;
    odataContext: string | undefined;
    value: Subscription[] | undefined;
}

export class ManageSubscriptionDTO implements IManageSubscriptionDTO {
    id!: number;
    planCode!: string | undefined;
    name!: string | undefined;
    typeId!: number;
    amount!: number;
    paymentUrl!: string | undefined;
    selectedFeatures!: string[];

    constructor(data?: IManageSubscriptionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.selectedFeatures = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.planCode = _data["planCode"];
            this.name = _data["name"];
            this.typeId = _data["typeId"];
            this.amount = _data["amount"];
            this.paymentUrl = _data["paymentUrl"];
            if (Array.isArray(_data["selectedFeatures"])) {
                this.selectedFeatures = [] as any;
                for (let item of _data["selectedFeatures"])
                    this.selectedFeatures!.push(item);
            }
        }
    }

    static fromJS(data: any): ManageSubscriptionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageSubscriptionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["planCode"] = this.planCode;
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["amount"] = this.amount;
        data["paymentUrl"] = this.paymentUrl;
        if (Array.isArray(this.selectedFeatures)) {
            data["selectedFeatures"] = [];
            for (let item of this.selectedFeatures)
                data["selectedFeatures"].push(item);
        }
        return data; 
    }

    clone(): ManageSubscriptionDTO {
        const json = this.toJSON();
        let result = new ManageSubscriptionDTO();
        result.init(json);
        return result;
    }
}

export interface IManageSubscriptionDTO {
    id: number;
    planCode: string | undefined;
    name: string | undefined;
    typeId: number;
    amount: number;
    paymentUrl: string | undefined;
    selectedFeatures: string[];
}

export class Title implements ITitle {
    id!: number;
    name!: string | undefined;
    dateCreated!: Date;
    modified!: Date | undefined;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: ITitle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): Title {
        data = typeof data === 'object' ? data : {};
        let result = new Title();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): Title {
        const json = this.toJSON();
        let result = new Title();
        result.init(json);
        return result;
    }
}

export interface ITitle {
    id: number;
    name: string | undefined;
    dateCreated: Date;
    modified: Date | undefined;
    isDeleted: boolean;
    isActive: boolean;
}

export class TitleIListOdataResult implements ITitleIListOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: Title[] | undefined;

    constructor(data?: ITitleIListOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Title.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TitleIListOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new TitleIListOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TitleIListOdataResult {
        const json = this.toJSON();
        let result = new TitleIListOdataResult();
        result.init(json);
        return result;
    }
}

export interface ITitleIListOdataResult {
    id: number;
    odataContext: string | undefined;
    value: Title[] | undefined;
}

export class ApplicationPermission implements IApplicationPermission {
    id!: number;
    name!: string | undefined;
    code!: string | undefined;
    moduleID!: number;
    applicationRolePermissions!: ApplicationRolePermission[] | undefined;

    constructor(data?: IApplicationPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.moduleID = _data["moduleID"];
            if (Array.isArray(_data["applicationRolePermissions"])) {
                this.applicationRolePermissions = [] as any;
                for (let item of _data["applicationRolePermissions"])
                    this.applicationRolePermissions!.push(ApplicationRolePermission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicationPermission {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationPermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["moduleID"] = this.moduleID;
        if (Array.isArray(this.applicationRolePermissions)) {
            data["applicationRolePermissions"] = [];
            for (let item of this.applicationRolePermissions)
                data["applicationRolePermissions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ApplicationPermission {
        const json = this.toJSON();
        let result = new ApplicationPermission();
        result.init(json);
        return result;
    }
}

export interface IApplicationPermission {
    id: number;
    name: string | undefined;
    code: string | undefined;
    moduleID: number;
    applicationRolePermissions: ApplicationRolePermission[] | undefined;
}

export class ApplicationRolePermission implements IApplicationRolePermission {
    id!: number;
    dateCreated!: Date;
    applicationRoleId!: number;
    applicationPermissionId!: number;
    applicationRole!: ApplicationRole;
    applicationPermission!: ApplicationPermission;

    constructor(data?: IApplicationRolePermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.applicationRoleId = _data["applicationRoleId"];
            this.applicationPermissionId = _data["applicationPermissionId"];
            this.applicationRole = _data["applicationRole"] ? ApplicationRole.fromJS(_data["applicationRole"]) : <any>undefined;
            this.applicationPermission = _data["applicationPermission"] ? ApplicationPermission.fromJS(_data["applicationPermission"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationRolePermission {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRolePermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["applicationRoleId"] = this.applicationRoleId;
        data["applicationPermissionId"] = this.applicationPermissionId;
        data["applicationRole"] = this.applicationRole ? this.applicationRole.toJSON() : <any>undefined;
        data["applicationPermission"] = this.applicationPermission ? this.applicationPermission.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ApplicationRolePermission {
        const json = this.toJSON();
        let result = new ApplicationRolePermission();
        result.init(json);
        return result;
    }
}

export interface IApplicationRolePermission {
    id: number;
    dateCreated: Date;
    applicationRoleId: number;
    applicationPermissionId: number;
    applicationRole: ApplicationRole;
    applicationPermission: ApplicationPermission;
}

export class ApplicationRole implements IApplicationRole {
    description!: string | undefined;
    isSystemRole!: boolean;
    applicationRolePermissions!: ApplicationRolePermission[] | undefined;
    id!: number;
    name!: string | undefined;
    normalizedName!: string | undefined;
    concurrencyStamp!: string | undefined;

    constructor(data?: IApplicationRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.isSystemRole = _data["isSystemRole"];
            if (Array.isArray(_data["applicationRolePermissions"])) {
                this.applicationRolePermissions = [] as any;
                for (let item of _data["applicationRolePermissions"])
                    this.applicationRolePermissions!.push(ApplicationRolePermission.fromJS(item));
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.normalizedName = _data["normalizedName"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): ApplicationRole {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["isSystemRole"] = this.isSystemRole;
        if (Array.isArray(this.applicationRolePermissions)) {
            data["applicationRolePermissions"] = [];
            for (let item of this.applicationRolePermissions)
                data["applicationRolePermissions"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["normalizedName"] = this.normalizedName;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data; 
    }

    clone(): ApplicationRole {
        const json = this.toJSON();
        let result = new ApplicationRole();
        result.init(json);
        return result;
    }
}

export interface IApplicationRole {
    description: string | undefined;
    isSystemRole: boolean;
    applicationRolePermissions: ApplicationRolePermission[] | undefined;
    id: number;
    name: string | undefined;
    normalizedName: string | undefined;
    concurrencyStamp: string | undefined;
}

export class RegisterUserDTO implements IRegisterUserDTO {
    firstName!: string;
    lastName!: string;
    email!: string;
    password!: string | undefined;
    phoneNumber!: string | undefined;
    selectedRoles!: string[];
    applicationRoles!: ApplicationRole[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRegisterUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.selectedRoles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.phoneNumber = _data["phoneNumber"];
            if (Array.isArray(_data["selectedRoles"])) {
                this.selectedRoles = [] as any;
                for (let item of _data["selectedRoles"])
                    this.selectedRoles!.push(item);
            }
            if (Array.isArray(_data["applicationRoles"])) {
                this.applicationRoles = [] as any;
                for (let item of _data["applicationRoles"])
                    this.applicationRoles!.push(ApplicationRole.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): RegisterUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["password"] = this.password;
        data["phoneNumber"] = this.phoneNumber;
        if (Array.isArray(this.selectedRoles)) {
            data["selectedRoles"] = [];
            for (let item of this.selectedRoles)
                data["selectedRoles"].push(item);
        }
        if (Array.isArray(this.applicationRoles)) {
            data["applicationRoles"] = [];
            for (let item of this.applicationRoles)
                data["applicationRoles"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): RegisterUserDTO {
        const json = this.toJSON();
        let result = new RegisterUserDTO();
        result.init(json);
        return result;
    }
}

export interface IRegisterUserDTO {
    firstName: string;
    lastName: string;
    email: string;
    password: string | undefined;
    phoneNumber: string | undefined;
    selectedRoles: string[];
    applicationRoles: ApplicationRole[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ApplicationUserDTO implements IApplicationUserDTO {
    id!: number;
    email!: string | undefined;
    username!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    isAdmin!: boolean;
    isTenantAdmin!: boolean;
    isEnabled!: boolean | undefined;
    lastLogin!: Date | undefined;
    companyId!: number;
    subsidiaryId!: number;
    token!: string | undefined;
    apiSessionId!: string | undefined;
    lastComputerName!: string | undefined;

    constructor(data?: IApplicationUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.username = _data["username"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.isAdmin = _data["isAdmin"];
            this.isTenantAdmin = _data["isTenantAdmin"];
            this.isEnabled = _data["isEnabled"];
            this.lastLogin = _data["lastLogin"] ? new Date(_data["lastLogin"].toString()) : <any>undefined;
            this.companyId = _data["companyId"];
            this.subsidiaryId = _data["subsidiaryId"];
            this.token = _data["token"];
            this.apiSessionId = _data["apiSessionId"];
            this.lastComputerName = _data["lastComputerName"];
        }
    }

    static fromJS(data: any): ApplicationUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["username"] = this.username;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["isAdmin"] = this.isAdmin;
        data["isTenantAdmin"] = this.isTenantAdmin;
        data["isEnabled"] = this.isEnabled;
        data["lastLogin"] = this.lastLogin ? this.lastLogin.toISOString() : <any>undefined;
        data["companyId"] = this.companyId;
        data["subsidiaryId"] = this.subsidiaryId;
        data["token"] = this.token;
        data["apiSessionId"] = this.apiSessionId;
        data["lastComputerName"] = this.lastComputerName;
        return data; 
    }

    clone(): ApplicationUserDTO {
        const json = this.toJSON();
        let result = new ApplicationUserDTO();
        result.init(json);
        return result;
    }
}

export interface IApplicationUserDTO {
    id: number;
    email: string | undefined;
    username: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    isAdmin: boolean;
    isTenantAdmin: boolean;
    isEnabled: boolean | undefined;
    lastLogin: Date | undefined;
    companyId: number;
    subsidiaryId: number;
    token: string | undefined;
    apiSessionId: string | undefined;
    lastComputerName: string | undefined;
}

export class ApplicationUserDTOIListApiResult implements IApplicationUserDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ApplicationUserDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IApplicationUserDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ApplicationUserDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ApplicationUserDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ApplicationUserDTOIListApiResult {
        const json = this.toJSON();
        let result = new ApplicationUserDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IApplicationUserDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ApplicationUserDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}