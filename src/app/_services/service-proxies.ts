/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.3.0 (NJsonSchema v10.4.4.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    applicantSignUp(body: ManageJobSeekerRegDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/ApplicantSignUp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApplicantSignUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApplicantSignUp(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processApplicantSignUp(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    employerSignUp(body: ManageEmployerDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/EmployerSignUp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployerSignUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployerSignUp(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processEmployerSignUp(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getToken(body: UserLoginDTO | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Account/GetToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToken(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetToken(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }

    /**
     * @param email (optional) 
     * @return Success
     */
    forgotPassword(email: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/ForgotPassword?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResestPasswordDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param token (optional) 
     * @return Success
     */
    confirmEmail(userId: string | null | undefined, token: string | null | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Account/ConfirmEmail?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmEmail(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmEmail(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }
}

@Injectable()
export class ApiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://recruitmentapi.azurewebsites.net";
    }

    /**
     * @return Success
     */
    countriesGet(): Observable<CountryOdataResult> {
        let url_ = this.baseUrl + "/api/Countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCountriesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountriesGet(<any>response_);
                } catch (e) {
                    return <Observable<CountryOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processCountriesGet(response: HttpResponseBase): Observable<CountryOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    countriesPost(body: Country | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Countries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCountriesPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountriesPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCountriesPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    countriesDelete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Countries?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCountriesDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountriesDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCountriesDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    courseGet(): Observable<CourseOdataResult> {
        let url_ = this.baseUrl + "/api/Course";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCourseGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCourseGet(<any>response_);
                } catch (e) {
                    return <Observable<CourseOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CourseOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processCourseGet(response: HttpResponseBase): Observable<CourseOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CourseOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CourseOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    coursePost(body: Course | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Course";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCoursePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCoursePost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCoursePost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    courseDelete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Course?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCourseDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCourseDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCourseDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    currenciesGet(): Observable<CurrencyOdataResult> {
        let url_ = this.baseUrl + "/api/Currencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrenciesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrenciesGet(<any>response_);
                } catch (e) {
                    return <Observable<CurrencyOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CurrencyOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processCurrenciesGet(response: HttpResponseBase): Observable<CurrencyOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrencyOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrencyOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    currenciesPost(body: Currency | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Currencies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrenciesPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrenciesPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCurrenciesPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    currenciesDelete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Currencies?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrenciesDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrenciesDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCurrenciesDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    employerTypesGet(): Observable<EmployerTypeOdataResult> {
        let url_ = this.baseUrl + "/api/EmployerTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployerTypesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployerTypesGet(<any>response_);
                } catch (e) {
                    return <Observable<EmployerTypeOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployerTypeOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processEmployerTypesGet(response: HttpResponseBase): Observable<EmployerTypeOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployerTypeOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployerTypeOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    employerTypesPost(body: EmployerType | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/EmployerTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployerTypesPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployerTypesPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEmployerTypesPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    employerTypesDelete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/EmployerTypes?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployerTypesDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployerTypesDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEmployerTypesDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    gradesGet(): Observable<GradeOdataResult> {
        let url_ = this.baseUrl + "/api/Grades";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGradesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGradesGet(<any>response_);
                } catch (e) {
                    return <Observable<GradeOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GradeOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processGradesGet(response: HttpResponseBase): Observable<GradeOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    gradesPost(body: Grade | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Grades";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGradesPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGradesPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGradesPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    gradesDelete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Grades?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGradesDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGradesDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGradesDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    institutionGet(): Observable<InstitutionOdataResult> {
        let url_ = this.baseUrl + "/api/Institution";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInstitutionGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInstitutionGet(<any>response_);
                } catch (e) {
                    return <Observable<InstitutionOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InstitutionOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processInstitutionGet(response: HttpResponseBase): Observable<InstitutionOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InstitutionOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InstitutionOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    institutionPost(body: Institution | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Institution";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInstitutionPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInstitutionPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInstitutionPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    institutionDelete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Institution?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInstitutionDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInstitutionDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInstitutionDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    jobTypesGet(): Observable<JobTypeOdataResult> {
        let url_ = this.baseUrl + "/api/JobTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processJobTypesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processJobTypesGet(<any>response_);
                } catch (e) {
                    return <Observable<JobTypeOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobTypeOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processJobTypesGet(response: HttpResponseBase): Observable<JobTypeOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobTypeOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobTypeOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    jobTypesPost(body: JobType | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/JobTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processJobTypesPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processJobTypesPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processJobTypesPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    jobTypesDelete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/JobTypes?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processJobTypesDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processJobTypesDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processJobTypesDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    qualificationGet(): Observable<QualificationOdataResult> {
        let url_ = this.baseUrl + "/api/Qualification";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQualificationGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQualificationGet(<any>response_);
                } catch (e) {
                    return <Observable<QualificationOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<QualificationOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processQualificationGet(response: HttpResponseBase): Observable<QualificationOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QualificationOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QualificationOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    qualificationPost(body: Qualification | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Qualification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQualificationPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQualificationPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processQualificationPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    qualificationDelete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Qualification?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQualificationDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQualificationDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processQualificationDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * API for getting all Roles for creating/updating Admin User as a Tenant Admin
     * @return Success
     */
    roleGet(): Observable<ApplicationRoleDTOOdataResult> {
        let url_ = this.baseUrl + "/api/Role";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRoleGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRoleGet(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationRoleDTOOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationRoleDTOOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processRoleGet(response: HttpResponseBase): Observable<ApplicationRoleDTOOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRoleDTOOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationRoleDTOOdataResult>(<any>null);
    }

    /**
     * API for Adding/Updating Roles as a Super Admin that possesses
    'Role Management' Privilege
     * @param body (optional) 
     * @return Success
     */
    rolePost(body: ApplicationRoleDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolePost(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRolePost(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @return Success
     */
    sectorsGet(): Observable<SectorOdataResult> {
        let url_ = this.baseUrl + "/api/Sectors";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSectorsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSectorsGet(<any>response_);
                } catch (e) {
                    return <Observable<SectorOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SectorOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processSectorsGet(response: HttpResponseBase): Observable<SectorOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SectorOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SectorOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sectorsPost(body: Sector | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Sectors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSectorsPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSectorsPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSectorsPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    sectorsDelete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Sectors?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSectorsDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSectorsDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSectorsDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    skillAreasGet(): Observable<SkillAreaOdataResult> {
        let url_ = this.baseUrl + "/api/SkillAreas";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSkillAreasGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSkillAreasGet(<any>response_);
                } catch (e) {
                    return <Observable<SkillAreaOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillAreaOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processSkillAreasGet(response: HttpResponseBase): Observable<SkillAreaOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SkillAreaOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillAreaOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    skillAreasPost(body: SkillArea | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/SkillAreas";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSkillAreasPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSkillAreasPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSkillAreasPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    skillAreasDelete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/SkillAreas?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSkillAreasDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSkillAreasDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSkillAreasDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    statesGet(): Observable<StateOdataResult> {
        let url_ = this.baseUrl + "/api/States";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatesGet(<any>response_);
                } catch (e) {
                    return <Observable<StateOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<StateOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processStatesGet(response: HttpResponseBase): Observable<StateOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StateOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StateOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    statesPost(body: State | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/States";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatesPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatesPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStatesPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    statesDelete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/States?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatesDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatesDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStatesDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    subscriptionsGet(): Observable<SubscriptionPlanDTOOdataResult> {
        let url_ = this.baseUrl + "/api/Subscriptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubscriptionsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionsGet(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPlanDTOOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPlanDTOOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processSubscriptionsGet(response: HttpResponseBase): Observable<SubscriptionPlanDTOOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPlanDTOOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPlanDTOOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    subscriptionsPost(body: ManageSubscriptionDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Subscriptions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubscriptionsPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionsPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSubscriptionsPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    subscriptionsDelete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Subscriptions?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubscriptionsDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscriptionsDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSubscriptionsDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    titlesGet(): Observable<TitleOdataResult> {
        let url_ = this.baseUrl + "/api/Titles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTitlesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTitlesGet(<any>response_);
                } catch (e) {
                    return <Observable<TitleOdataResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TitleOdataResult>><any>_observableThrow(response_);
        }));
    }

    protected processTitlesGet(response: HttpResponseBase): Observable<TitleOdataResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TitleOdataResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TitleOdataResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    titlesPost(body: Title | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Titles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTitlesPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTitlesPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTitlesPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    titlesDelete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Titles?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTitlesDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTitlesDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTitlesDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    userManagementPost(body: RegisterUserDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/UserManagement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserManagementPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserManagementPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUserManagementPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    userManagementPatch(body: RegisterUserDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/UserManagement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserManagementPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserManagementPatch(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUserManagementPatch(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    userManagementGet(): Observable<ApplicationUserDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/UserManagement";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json;odata.metadata=minimal;odata.streaming=true"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserManagementGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserManagementGet(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationUserDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationUserDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUserManagementGet(response: HttpResponseBase): Observable<ApplicationUserDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUserDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUserDTOIListApiResult>(<any>null);
    }
}

export class ManageJobSeekerRegDTO implements IManageJobSeekerRegDTO {
    id!: number;
    titleId!: number;
    firstName!: string;
    lastname!: string;
    email!: string | undefined;
    dateOfBirth!: Date;
    genderId!: number;
    nationalityId!: number;
    residentialStateId!: number;
    phoneNumber!: string | undefined;
    password!: string;
    fieldOfInterestId!: number;
    stateOfInterestId!: number;
    yearOfExperience!: number;
    availabilityDuration!: number;
    qualificationId!: number;
    courseOfStudyId!: number;
    institutionId!: number;
    institutionName!: string | undefined;
    gradeId!: number;
    qualificationStartDate!: Date;
    qualificationEndDate!: Date;
    currentJobTitle!: string | undefined;
    companyName!: string | undefined;
    workStartDate!: Date;
    workEndDate!: Date | undefined;
    isPresentEmployment!: boolean;
    resume!: string | undefined;
    videoResume!: string | undefined;
    briefDescription!: string | undefined;
    readonly title!: string | undefined;
    readonly sex!: string | undefined;

    constructor(data?: IManageJobSeekerRegDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.titleId = _data["titleId"];
            this.firstName = _data["firstName"];
            this.lastname = _data["lastname"];
            this.email = _data["email"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.genderId = _data["genderId"];
            this.nationalityId = _data["nationalityId"];
            this.residentialStateId = _data["residentialStateId"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
            this.fieldOfInterestId = _data["fieldOfInterestId"];
            this.stateOfInterestId = _data["stateOfInterestId"];
            this.yearOfExperience = _data["yearOfExperience"];
            this.availabilityDuration = _data["availabilityDuration"];
            this.qualificationId = _data["qualificationId"];
            this.courseOfStudyId = _data["courseOfStudyId"];
            this.institutionId = _data["institutionId"];
            this.institutionName = _data["institutionName"];
            this.gradeId = _data["gradeId"];
            this.qualificationStartDate = _data["qualificationStartDate"] ? new Date(_data["qualificationStartDate"].toString()) : <any>undefined;
            this.qualificationEndDate = _data["qualificationEndDate"] ? new Date(_data["qualificationEndDate"].toString()) : <any>undefined;
            this.currentJobTitle = _data["currentJobTitle"];
            this.companyName = _data["companyName"];
            this.workStartDate = _data["workStartDate"] ? new Date(_data["workStartDate"].toString()) : <any>undefined;
            this.workEndDate = _data["workEndDate"] ? new Date(_data["workEndDate"].toString()) : <any>undefined;
            this.isPresentEmployment = _data["isPresentEmployment"];
            this.resume = _data["resume"];
            this.videoResume = _data["videoResume"];
            this.briefDescription = _data["briefDescription"];
            (<any>this).title = _data["title"];
            (<any>this).sex = _data["sex"];
        }
    }

    static fromJS(data: any): ManageJobSeekerRegDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageJobSeekerRegDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["titleId"] = this.titleId;
        data["firstName"] = this.firstName;
        data["lastname"] = this.lastname;
        data["email"] = this.email;
        data["dateOfBirth"] = this.dateOfBirth ? formatDate(this.dateOfBirth) : <any>undefined;
        data["genderId"] = this.genderId;
        data["nationalityId"] = this.nationalityId;
        data["residentialStateId"] = this.residentialStateId;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["fieldOfInterestId"] = this.fieldOfInterestId;
        data["stateOfInterestId"] = this.stateOfInterestId;
        data["yearOfExperience"] = this.yearOfExperience;
        data["availabilityDuration"] = this.availabilityDuration;
        data["qualificationId"] = this.qualificationId;
        data["courseOfStudyId"] = this.courseOfStudyId;
        data["institutionId"] = this.institutionId;
        data["institutionName"] = this.institutionName;
        data["gradeId"] = this.gradeId;
        data["qualificationStartDate"] = this.qualificationStartDate ? this.qualificationStartDate.toISOString() : <any>undefined;
        data["qualificationEndDate"] = this.qualificationEndDate ? this.qualificationEndDate.toISOString() : <any>undefined;
        data["currentJobTitle"] = this.currentJobTitle;
        data["companyName"] = this.companyName;
        data["workStartDate"] = this.workStartDate ? this.workStartDate.toISOString() : <any>undefined;
        data["workEndDate"] = this.workEndDate ? this.workEndDate.toISOString() : <any>undefined;
        data["isPresentEmployment"] = this.isPresentEmployment;
        data["resume"] = this.resume;
        data["videoResume"] = this.videoResume;
        data["briefDescription"] = this.briefDescription;
        data["title"] = this.title;
        data["sex"] = this.sex;
        return data; 
    }

    clone(): ManageJobSeekerRegDTO {
        const json = this.toJSON();
        let result = new ManageJobSeekerRegDTO();
        result.init(json);
        return result;
    }
}

export interface IManageJobSeekerRegDTO {
    id: number;
    titleId: number;
    firstName: string;
    lastname: string;
    email: string | undefined;
    dateOfBirth: Date;
    genderId: number;
    nationalityId: number;
    residentialStateId: number;
    phoneNumber: string | undefined;
    password: string;
    fieldOfInterestId: number;
    stateOfInterestId: number;
    yearOfExperience: number;
    availabilityDuration: number;
    qualificationId: number;
    courseOfStudyId: number;
    institutionId: number;
    institutionName: string | undefined;
    gradeId: number;
    qualificationStartDate: Date;
    qualificationEndDate: Date;
    currentJobTitle: string | undefined;
    companyName: string | undefined;
    workStartDate: Date;
    workEndDate: Date | undefined;
    isPresentEmployment: boolean;
    resume: string | undefined;
    videoResume: string | undefined;
    briefDescription: string | undefined;
    title: string | undefined;
    sex: string | undefined;
}

export class MessageOut implements IMessageOut {
    message!: string | undefined;
    isSuccessful!: boolean;
    retId!: number;
    bulkUploadId!: number;
    bulkUploadHtmlData!: string | undefined;
    redirectUrl!: string | undefined;
    referenceNumber!: string | undefined;
    errors!: string[] | undefined;

    constructor(data?: IMessageOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.isSuccessful = _data["isSuccessful"];
            this.retId = _data["retId"];
            this.bulkUploadId = _data["bulkUploadId"];
            this.bulkUploadHtmlData = _data["bulkUploadHtmlData"];
            this.redirectUrl = _data["redirectUrl"];
            this.referenceNumber = _data["referenceNumber"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): MessageOut {
        data = typeof data === 'object' ? data : {};
        let result = new MessageOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["isSuccessful"] = this.isSuccessful;
        data["retId"] = this.retId;
        data["bulkUploadId"] = this.bulkUploadId;
        data["bulkUploadHtmlData"] = this.bulkUploadHtmlData;
        data["redirectUrl"] = this.redirectUrl;
        data["referenceNumber"] = this.referenceNumber;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }

    clone(): MessageOut {
        const json = this.toJSON();
        let result = new MessageOut();
        result.init(json);
        return result;
    }
}

export interface IMessageOut {
    message: string | undefined;
    isSuccessful: boolean;
    retId: number;
    bulkUploadId: number;
    bulkUploadHtmlData: string | undefined;
    redirectUrl: string | undefined;
    referenceNumber: string | undefined;
    errors: string[] | undefined;
}

export class MessageOutApiResult implements IMessageOutApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: MessageOut;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IMessageOutApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? MessageOut.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): MessageOutApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new MessageOutApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): MessageOutApiResult {
        const json = this.toJSON();
        let result = new MessageOutApiResult();
        result.init(json);
        return result;
    }
}

export interface IMessageOutApiResult {
    hasError: boolean;
    message: string | undefined;
    result: MessageOut;
    totalCount: number;
    totalRecord: number;
}

export class ManageEmployerDTO implements IManageEmployerDTO {
    id!: number;
    name!: string;
    firstName!: string;
    lastName!: string;
    subscriptionPlanId!: number;
    isTrial!: boolean;
    tempRef!: string | undefined;
    contactPerson!: string;
    email!: string;
    password!: string;
    confirmPassword!: string;
    mobile!: string | undefined;
    sectorId!: number;
    logo!: string | undefined;
    employerTypeId!: number;

    constructor(data?: IManageEmployerDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.isTrial = _data["isTrial"];
            this.tempRef = _data["tempRef"];
            this.contactPerson = _data["contactPerson"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            this.mobile = _data["mobile"];
            this.sectorId = _data["sectorId"];
            this.logo = _data["logo"];
            this.employerTypeId = _data["employerTypeId"];
        }
    }

    static fromJS(data: any): ManageEmployerDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageEmployerDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["isTrial"] = this.isTrial;
        data["tempRef"] = this.tempRef;
        data["contactPerson"] = this.contactPerson;
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        data["mobile"] = this.mobile;
        data["sectorId"] = this.sectorId;
        data["logo"] = this.logo;
        data["employerTypeId"] = this.employerTypeId;
        return data; 
    }

    clone(): ManageEmployerDTO {
        const json = this.toJSON();
        let result = new ManageEmployerDTO();
        result.init(json);
        return result;
    }
}

export interface IManageEmployerDTO {
    id: number;
    name: string;
    firstName: string;
    lastName: string;
    subscriptionPlanId: number;
    isTrial: boolean;
    tempRef: string | undefined;
    contactPerson: string;
    email: string;
    password: string;
    confirmPassword: string;
    mobile: string | undefined;
    sectorId: number;
    logo: string | undefined;
    employerTypeId: number;
}

export class UserLoginDTO implements IUserLoginDTO {
    email!: string | undefined;
    password!: string | undefined;

    constructor(data?: IUserLoginDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): UserLoginDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data; 
    }

    clone(): UserLoginDTO {
        const json = this.toJSON();
        let result = new UserLoginDTO();
        result.init(json);
        return result;
    }
}

export interface IUserLoginDTO {
    email: string | undefined;
    password: string | undefined;
}

export class CompanyDTO implements ICompanyDTO {
    id!: number;
    userId!: number;
    name!: string;
    rcNo!: string | undefined;
    logoName!: string | undefined;
    shortText!: string | undefined;
    email!: string;
    phoneNumber!: string;
    firstName!: string | undefined;
    lastName!: string | undefined;
    address!: string | undefined;
    administratorEmail!: string;
    domainName!: string | undefined;
    auditorEmail!: string | undefined;
    maxEmployeeCount!: number;
    subscriptionPlanId!: number;
    subscriptionPlanName!: string | undefined;
    lastBillingDate!: Date | undefined;
    lastPaymentDate!: Date | undefined;
    licenseUsage!: number;
    isActiveByAdmin!: boolean;
    isTrial!: boolean;
    password!: string;
    frequencyId!: number;
    tempRef!: string | undefined;
    referenceNumber!: string | undefined;

    constructor(data?: ICompanyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.rcNo = _data["rcNo"];
            this.logoName = _data["logoName"];
            this.shortText = _data["shortText"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.address = _data["address"];
            this.administratorEmail = _data["administratorEmail"];
            this.domainName = _data["domainName"];
            this.auditorEmail = _data["auditorEmail"];
            this.maxEmployeeCount = _data["maxEmployeeCount"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.subscriptionPlanName = _data["subscriptionPlanName"];
            this.lastBillingDate = _data["lastBillingDate"] ? new Date(_data["lastBillingDate"].toString()) : <any>undefined;
            this.lastPaymentDate = _data["lastPaymentDate"] ? new Date(_data["lastPaymentDate"].toString()) : <any>undefined;
            this.licenseUsage = _data["licenseUsage"];
            this.isActiveByAdmin = _data["isActiveByAdmin"];
            this.isTrial = _data["isTrial"];
            this.password = _data["password"];
            this.frequencyId = _data["frequencyId"];
            this.tempRef = _data["tempRef"];
            this.referenceNumber = _data["referenceNumber"];
        }
    }

    static fromJS(data: any): CompanyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["rcNo"] = this.rcNo;
        data["logoName"] = this.logoName;
        data["shortText"] = this.shortText;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["address"] = this.address;
        data["administratorEmail"] = this.administratorEmail;
        data["domainName"] = this.domainName;
        data["auditorEmail"] = this.auditorEmail;
        data["maxEmployeeCount"] = this.maxEmployeeCount;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["subscriptionPlanName"] = this.subscriptionPlanName;
        data["lastBillingDate"] = this.lastBillingDate ? this.lastBillingDate.toISOString() : <any>undefined;
        data["lastPaymentDate"] = this.lastPaymentDate ? this.lastPaymentDate.toISOString() : <any>undefined;
        data["licenseUsage"] = this.licenseUsage;
        data["isActiveByAdmin"] = this.isActiveByAdmin;
        data["isTrial"] = this.isTrial;
        data["password"] = this.password;
        data["frequencyId"] = this.frequencyId;
        data["tempRef"] = this.tempRef;
        data["referenceNumber"] = this.referenceNumber;
        return data; 
    }

    clone(): CompanyDTO {
        const json = this.toJSON();
        let result = new CompanyDTO();
        result.init(json);
        return result;
    }
}

export interface ICompanyDTO {
    id: number;
    userId: number;
    name: string;
    rcNo: string | undefined;
    logoName: string | undefined;
    shortText: string | undefined;
    email: string;
    phoneNumber: string;
    firstName: string | undefined;
    lastName: string | undefined;
    address: string | undefined;
    administratorEmail: string;
    domainName: string | undefined;
    auditorEmail: string | undefined;
    maxEmployeeCount: number;
    subscriptionPlanId: number;
    subscriptionPlanName: string | undefined;
    lastBillingDate: Date | undefined;
    lastPaymentDate: Date | undefined;
    licenseUsage: number;
    isActiveByAdmin: boolean;
    isTrial: boolean;
    password: string;
    frequencyId: number;
    tempRef: string | undefined;
    referenceNumber: string | undefined;
}

export class VwUserObj implements IVwUserObj {
    user_id!: number;
    employee_id!: number;
    employee_number!: string | undefined;
    employee_contract_id!: number;
    supervisor_contract_id!: number;
    supervisor_employee_id!: number;
    supervisor_full_name!: string | undefined;
    companyProfile!: CompanyDTO;
    grade_id!: number | undefined;
    confirmation_date!: Date | undefined;
    serial_no!: string | undefined;
    first_name!: string | undefined;
    last_name!: string | undefined;
    readonly full_name!: string | undefined;
    other_name!: string | undefined;
    department!: string | undefined;
    department_id!: number;
    email!: string | undefined;
    phone_number!: string | undefined;
    email_confirmed!: boolean;
    session_token!: string | undefined;
    jwt_token!: string | undefined;
    user_token!: string | undefined;
    company_id!: number;
    licenseUsuage!: number;
    licenseCount!: number;
    company_name!: string | undefined;
    sub_id!: number;
    isAdmin!: boolean;
    isSuperAdmin!: boolean;
    isTenantAdmin!: boolean;
    isActiveBySysOrAdmin!: boolean;
    lstPermissions!: string[] | undefined;
    message!: string | undefined;
    isSuccessful!: boolean;
    retId!: number;
    bulkUploadId!: number;
    bulkUploadHtmlData!: string | undefined;
    redirectUrl!: string | undefined;
    referenceNumber!: string | undefined;
    errors!: string[] | undefined;

    constructor(data?: IVwUserObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user_id = _data["user_id"];
            this.employee_id = _data["employee_id"];
            this.employee_number = _data["employee_number"];
            this.employee_contract_id = _data["employee_contract_id"];
            this.supervisor_contract_id = _data["supervisor_contract_id"];
            this.supervisor_employee_id = _data["supervisor_employee_id"];
            this.supervisor_full_name = _data["supervisor_full_name"];
            this.companyProfile = _data["companyProfile"] ? CompanyDTO.fromJS(_data["companyProfile"]) : <any>undefined;
            this.grade_id = _data["grade_id"];
            this.confirmation_date = _data["confirmation_date"] ? new Date(_data["confirmation_date"].toString()) : <any>undefined;
            this.serial_no = _data["serial_no"];
            this.first_name = _data["first_name"];
            this.last_name = _data["last_name"];
            (<any>this).full_name = _data["full_name"];
            this.other_name = _data["other_name"];
            this.department = _data["department"];
            this.department_id = _data["department_id"];
            this.email = _data["email"];
            this.phone_number = _data["phone_number"];
            this.email_confirmed = _data["email_confirmed"];
            this.session_token = _data["session_token"];
            this.jwt_token = _data["jwt_token"];
            this.user_token = _data["user_token"];
            this.company_id = _data["company_id"];
            this.licenseUsuage = _data["licenseUsuage"];
            this.licenseCount = _data["licenseCount"];
            this.company_name = _data["company_name"];
            this.sub_id = _data["sub_id"];
            this.isAdmin = _data["isAdmin"];
            this.isSuperAdmin = _data["isSuperAdmin"];
            this.isTenantAdmin = _data["isTenantAdmin"];
            this.isActiveBySysOrAdmin = _data["isActiveBySysOrAdmin"];
            if (Array.isArray(_data["lstPermissions"])) {
                this.lstPermissions = [] as any;
                for (let item of _data["lstPermissions"])
                    this.lstPermissions!.push(item);
            }
            this.message = _data["message"];
            this.isSuccessful = _data["isSuccessful"];
            this.retId = _data["retId"];
            this.bulkUploadId = _data["bulkUploadId"];
            this.bulkUploadHtmlData = _data["bulkUploadHtmlData"];
            this.redirectUrl = _data["redirectUrl"];
            this.referenceNumber = _data["referenceNumber"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): VwUserObj {
        data = typeof data === 'object' ? data : {};
        let result = new VwUserObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user_id"] = this.user_id;
        data["employee_id"] = this.employee_id;
        data["employee_number"] = this.employee_number;
        data["employee_contract_id"] = this.employee_contract_id;
        data["supervisor_contract_id"] = this.supervisor_contract_id;
        data["supervisor_employee_id"] = this.supervisor_employee_id;
        data["supervisor_full_name"] = this.supervisor_full_name;
        data["companyProfile"] = this.companyProfile ? this.companyProfile.toJSON() : <any>undefined;
        data["grade_id"] = this.grade_id;
        data["confirmation_date"] = this.confirmation_date ? this.confirmation_date.toISOString() : <any>undefined;
        data["serial_no"] = this.serial_no;
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        data["full_name"] = this.full_name;
        data["other_name"] = this.other_name;
        data["department"] = this.department;
        data["department_id"] = this.department_id;
        data["email"] = this.email;
        data["phone_number"] = this.phone_number;
        data["email_confirmed"] = this.email_confirmed;
        data["session_token"] = this.session_token;
        data["jwt_token"] = this.jwt_token;
        data["user_token"] = this.user_token;
        data["company_id"] = this.company_id;
        data["licenseUsuage"] = this.licenseUsuage;
        data["licenseCount"] = this.licenseCount;
        data["company_name"] = this.company_name;
        data["sub_id"] = this.sub_id;
        data["isAdmin"] = this.isAdmin;
        data["isSuperAdmin"] = this.isSuperAdmin;
        data["isTenantAdmin"] = this.isTenantAdmin;
        data["isActiveBySysOrAdmin"] = this.isActiveBySysOrAdmin;
        if (Array.isArray(this.lstPermissions)) {
            data["lstPermissions"] = [];
            for (let item of this.lstPermissions)
                data["lstPermissions"].push(item);
        }
        data["message"] = this.message;
        data["isSuccessful"] = this.isSuccessful;
        data["retId"] = this.retId;
        data["bulkUploadId"] = this.bulkUploadId;
        data["bulkUploadHtmlData"] = this.bulkUploadHtmlData;
        data["redirectUrl"] = this.redirectUrl;
        data["referenceNumber"] = this.referenceNumber;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }

    clone(): VwUserObj {
        const json = this.toJSON();
        let result = new VwUserObj();
        result.init(json);
        return result;
    }
}

export interface IVwUserObj {
    user_id: number;
    employee_id: number;
    employee_number: string | undefined;
    employee_contract_id: number;
    supervisor_contract_id: number;
    supervisor_employee_id: number;
    supervisor_full_name: string | undefined;
    companyProfile: CompanyDTO;
    grade_id: number | undefined;
    confirmation_date: Date | undefined;
    serial_no: string | undefined;
    first_name: string | undefined;
    last_name: string | undefined;
    full_name: string | undefined;
    other_name: string | undefined;
    department: string | undefined;
    department_id: number;
    email: string | undefined;
    phone_number: string | undefined;
    email_confirmed: boolean;
    session_token: string | undefined;
    jwt_token: string | undefined;
    user_token: string | undefined;
    company_id: number;
    licenseUsuage: number;
    licenseCount: number;
    company_name: string | undefined;
    sub_id: number;
    isAdmin: boolean;
    isSuperAdmin: boolean;
    isTenantAdmin: boolean;
    isActiveBySysOrAdmin: boolean;
    lstPermissions: string[] | undefined;
    message: string | undefined;
    isSuccessful: boolean;
    retId: number;
    bulkUploadId: number;
    bulkUploadHtmlData: string | undefined;
    redirectUrl: string | undefined;
    referenceNumber: string | undefined;
    errors: string[] | undefined;
}

export class VwUserObjApiResult implements IVwUserObjApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: VwUserObj;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IVwUserObjApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? VwUserObj.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): VwUserObjApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new VwUserObjApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): VwUserObjApiResult {
        const json = this.toJSON();
        let result = new VwUserObjApiResult();
        result.init(json);
        return result;
    }
}

export interface IVwUserObjApiResult {
    hasError: boolean;
    message: string | undefined;
    result: VwUserObj;
    totalCount: number;
    totalRecord: number;
}

export class ResestPasswordDTO implements IResestPasswordDTO {
    token!: string | undefined;
    email!: string;
    password!: string;
    confirmPassword!: string | undefined;

    constructor(data?: IResestPasswordDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ResestPasswordDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResestPasswordDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data; 
    }

    clone(): ResestPasswordDTO {
        const json = this.toJSON();
        let result = new ResestPasswordDTO();
        result.init(json);
        return result;
    }
}

export interface IResestPasswordDTO {
    token: string | undefined;
    email: string;
    password: string;
    confirmPassword: string | undefined;
}

export class Alertmode implements IAlertmode {
    id!: number;
    name!: string | undefined;
    registeredUsers!: RegisteredUser[] | undefined;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IAlertmode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["registeredUsers"])) {
                this.registeredUsers = [] as any;
                for (let item of _data["registeredUsers"])
                    this.registeredUsers!.push(RegisteredUser.fromJS(item));
            }
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Alertmode {
        data = typeof data === 'object' ? data : {};
        let result = new Alertmode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.registeredUsers)) {
            data["registeredUsers"] = [];
            for (let item of this.registeredUsers)
                data["registeredUsers"].push(item.toJSON());
        }
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Alertmode {
        const json = this.toJSON();
        let result = new Alertmode();
        result.init(json);
        return result;
    }
}

export interface IAlertmode {
    id: number;
    name: string | undefined;
    registeredUsers: RegisteredUser[] | undefined;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Job implements IJob {
    details!: string | undefined;
    requirements!: string | undefined;
    position!: string | undefined;
    recruiter!: string | undefined;
    countryId!: number;
    stateId!: number;
    location!: string | undefined;
    jobTypeId!: number;
    minExpRequired!: number | undefined;
    maxExpRequired!: number | undefined;
    minSalary!: number | undefined;
    maxSalary!: number | undefined;
    minQualificationId!: number | undefined;
    maxQualificationId!: number | undefined;
    quizId!: number | undefined;
    currencyId!: number | undefined;
    skillAreaId!: number;
    reviewers!: string | undefined;
    clicks!: number;
    endDate!: Date;
    datePosted!: Date;
    ref!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.details = _data["details"];
            this.requirements = _data["requirements"];
            this.position = _data["position"];
            this.recruiter = _data["recruiter"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.location = _data["location"];
            this.jobTypeId = _data["jobTypeId"];
            this.minExpRequired = _data["minExpRequired"];
            this.maxExpRequired = _data["maxExpRequired"];
            this.minSalary = _data["minSalary"];
            this.maxSalary = _data["maxSalary"];
            this.minQualificationId = _data["minQualificationId"];
            this.maxQualificationId = _data["maxQualificationId"];
            this.quizId = _data["quizId"];
            this.currencyId = _data["currencyId"];
            this.skillAreaId = _data["skillAreaId"];
            this.reviewers = _data["reviewers"];
            this.clicks = _data["clicks"];
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.datePosted = _data["datePosted"] ? new Date(_data["datePosted"].toString()) : <any>undefined;
            this.ref = _data["ref"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Job {
        data = typeof data === 'object' ? data : {};
        let result = new Job();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["details"] = this.details;
        data["requirements"] = this.requirements;
        data["position"] = this.position;
        data["recruiter"] = this.recruiter;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["location"] = this.location;
        data["jobTypeId"] = this.jobTypeId;
        data["minExpRequired"] = this.minExpRequired;
        data["maxExpRequired"] = this.maxExpRequired;
        data["minSalary"] = this.minSalary;
        data["maxSalary"] = this.maxSalary;
        data["minQualificationId"] = this.minQualificationId;
        data["maxQualificationId"] = this.maxQualificationId;
        data["quizId"] = this.quizId;
        data["currencyId"] = this.currencyId;
        data["skillAreaId"] = this.skillAreaId;
        data["reviewers"] = this.reviewers;
        data["clicks"] = this.clicks;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["datePosted"] = this.datePosted ? this.datePosted.toISOString() : <any>undefined;
        data["ref"] = this.ref;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Job {
        const json = this.toJSON();
        let result = new Job();
        result.init(json);
        return result;
    }
}

export interface IJob {
    details: string | undefined;
    requirements: string | undefined;
    position: string | undefined;
    recruiter: string | undefined;
    countryId: number;
    stateId: number;
    location: string | undefined;
    jobTypeId: number;
    minExpRequired: number | undefined;
    maxExpRequired: number | undefined;
    minSalary: number | undefined;
    maxSalary: number | undefined;
    minQualificationId: number | undefined;
    maxQualificationId: number | undefined;
    quizId: number | undefined;
    currencyId: number | undefined;
    skillAreaId: number;
    reviewers: string | undefined;
    clicks: number;
    endDate: Date;
    datePosted: Date;
    ref: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class RecruitmentStage implements IRecruitmentStage {
    id!: number;
    rank!: number;
    name!: string | undefined;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRecruitmentStage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rank = _data["rank"];
            this.name = _data["name"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): RecruitmentStage {
        data = typeof data === 'object' ? data : {};
        let result = new RecruitmentStage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rank"] = this.rank;
        data["name"] = this.name;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): RecruitmentStage {
        const json = this.toJSON();
        let result = new RecruitmentStage();
        result.init(json);
        return result;
    }
}

export interface IRecruitmentStage {
    id: number;
    rank: number;
    name: string | undefined;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class AppliedApplicant implements IAppliedApplicant {
    jobId!: number;
    applicantCode!: string | undefined;
    registeredUserId!: number;
    dateApplied!: Date;
    lastUpdate!: Date | undefined;
    alertSent!: boolean;
    coverLetter!: string | undefined;
    jobLocation!: number | undefined;
    recruitmentStageId!: number | undefined;
    testPassCode!: string | undefined;
    job!: Job;
    recruitmentStage!: RecruitmentStage;
    registeredUser!: RegisteredUser;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IAppliedApplicant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
            this.applicantCode = _data["applicantCode"];
            this.registeredUserId = _data["registeredUserId"];
            this.dateApplied = _data["dateApplied"] ? new Date(_data["dateApplied"].toString()) : <any>undefined;
            this.lastUpdate = _data["lastUpdate"] ? new Date(_data["lastUpdate"].toString()) : <any>undefined;
            this.alertSent = _data["alertSent"];
            this.coverLetter = _data["coverLetter"];
            this.jobLocation = _data["jobLocation"];
            this.recruitmentStageId = _data["recruitmentStageId"];
            this.testPassCode = _data["testPassCode"];
            this.job = _data["job"] ? Job.fromJS(_data["job"]) : <any>undefined;
            this.recruitmentStage = _data["recruitmentStage"] ? RecruitmentStage.fromJS(_data["recruitmentStage"]) : <any>undefined;
            this.registeredUser = _data["registeredUser"] ? RegisteredUser.fromJS(_data["registeredUser"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): AppliedApplicant {
        data = typeof data === 'object' ? data : {};
        let result = new AppliedApplicant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["applicantCode"] = this.applicantCode;
        data["registeredUserId"] = this.registeredUserId;
        data["dateApplied"] = this.dateApplied ? this.dateApplied.toISOString() : <any>undefined;
        data["lastUpdate"] = this.lastUpdate ? this.lastUpdate.toISOString() : <any>undefined;
        data["alertSent"] = this.alertSent;
        data["coverLetter"] = this.coverLetter;
        data["jobLocation"] = this.jobLocation;
        data["recruitmentStageId"] = this.recruitmentStageId;
        data["testPassCode"] = this.testPassCode;
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        data["recruitmentStage"] = this.recruitmentStage ? this.recruitmentStage.toJSON() : <any>undefined;
        data["registeredUser"] = this.registeredUser ? this.registeredUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): AppliedApplicant {
        const json = this.toJSON();
        let result = new AppliedApplicant();
        result.init(json);
        return result;
    }
}

export interface IAppliedApplicant {
    jobId: number;
    applicantCode: string | undefined;
    registeredUserId: number;
    dateApplied: Date;
    lastUpdate: Date | undefined;
    alertSent: boolean;
    coverLetter: string | undefined;
    jobLocation: number | undefined;
    recruitmentStageId: number | undefined;
    testPassCode: string | undefined;
    job: Job;
    recruitmentStage: RecruitmentStage;
    registeredUser: RegisteredUser;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class JobCourse implements IJobCourse {
    courseId!: number;
    jobId!: number;
    course!: Course;
    job!: Job;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IJobCourse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.courseId = _data["courseId"];
            this.jobId = _data["jobId"];
            this.course = _data["course"] ? Course.fromJS(_data["course"]) : <any>undefined;
            this.job = _data["job"] ? Job.fromJS(_data["job"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): JobCourse {
        data = typeof data === 'object' ? data : {};
        let result = new JobCourse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["courseId"] = this.courseId;
        data["jobId"] = this.jobId;
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): JobCourse {
        const json = this.toJSON();
        let result = new JobCourse();
        result.init(json);
        return result;
    }
}

export interface IJobCourse {
    courseId: number;
    jobId: number;
    course: Course;
    job: Job;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Course implements ICourse {
    name!: string | undefined;
    jobCourses!: JobCourse[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICourse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["jobCourses"])) {
                this.jobCourses = [] as any;
                for (let item of _data["jobCourses"])
                    this.jobCourses!.push(JobCourse.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Course {
        data = typeof data === 'object' ? data : {};
        let result = new Course();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.jobCourses)) {
            data["jobCourses"] = [];
            for (let item of this.jobCourses)
                data["jobCourses"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Course {
        const json = this.toJSON();
        let result = new Course();
        result.init(json);
        return result;
    }
}

export interface ICourse {
    name: string | undefined;
    jobCourses: JobCourse[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Qualification implements IQualification {
    categoryId!: number;
    name!: string | undefined;
    code!: string | undefined;
    point!: number | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IQualification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.point = _data["point"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Qualification {
        data = typeof data === 'object' ? data : {};
        let result = new Qualification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["point"] = this.point;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Qualification {
        const json = this.toJSON();
        let result = new Qualification();
        result.init(json);
        return result;
    }
}

export interface IQualification {
    categoryId: number;
    name: string | undefined;
    code: string | undefined;
    point: number | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Institution implements IInstitution {
    name!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IInstitution) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Institution {
        data = typeof data === 'object' ? data : {};
        let result = new Institution();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Institution {
        const json = this.toJSON();
        let result = new Institution();
        result.init(json);
        return result;
    }
}

export interface IInstitution {
    name: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Education implements IEducation {
    registeredUserId!: number;
    qualificationId!: number | undefined;
    disciplineId!: number | undefined;
    startDate!: Date;
    endDate!: Date;
    gradeId!: number | undefined;
    institutionId!: number | undefined;
    institutionName!: string | undefined;
    courseId!: number | undefined;
    course!: Course;
    qualification!: Qualification;
    institution!: Institution;
    registeredUser!: RegisteredUser;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEducation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registeredUserId = _data["registeredUserId"];
            this.qualificationId = _data["qualificationId"];
            this.disciplineId = _data["disciplineId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.gradeId = _data["gradeId"];
            this.institutionId = _data["institutionId"];
            this.institutionName = _data["institutionName"];
            this.courseId = _data["courseId"];
            this.course = _data["course"] ? Course.fromJS(_data["course"]) : <any>undefined;
            this.qualification = _data["qualification"] ? Qualification.fromJS(_data["qualification"]) : <any>undefined;
            this.institution = _data["institution"] ? Institution.fromJS(_data["institution"]) : <any>undefined;
            this.registeredUser = _data["registeredUser"] ? RegisteredUser.fromJS(_data["registeredUser"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Education {
        data = typeof data === 'object' ? data : {};
        let result = new Education();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registeredUserId"] = this.registeredUserId;
        data["qualificationId"] = this.qualificationId;
        data["disciplineId"] = this.disciplineId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["gradeId"] = this.gradeId;
        data["institutionId"] = this.institutionId;
        data["institutionName"] = this.institutionName;
        data["courseId"] = this.courseId;
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        data["qualification"] = this.qualification ? this.qualification.toJSON() : <any>undefined;
        data["institution"] = this.institution ? this.institution.toJSON() : <any>undefined;
        data["registeredUser"] = this.registeredUser ? this.registeredUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Education {
        const json = this.toJSON();
        let result = new Education();
        result.init(json);
        return result;
    }
}

export interface IEducation {
    registeredUserId: number;
    qualificationId: number | undefined;
    disciplineId: number | undefined;
    startDate: Date;
    endDate: Date;
    gradeId: number | undefined;
    institutionId: number | undefined;
    institutionName: string | undefined;
    courseId: number | undefined;
    course: Course;
    qualification: Qualification;
    institution: Institution;
    registeredUser: RegisteredUser;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Company implements ICompany {
    id!: number;
    name!: string | undefined;
    contactPerson!: string | undefined;
    email!: string | undefined;
    mobile!: string | undefined;
    nowRecruiting!: boolean;
    registered!: boolean;
    sectorId!: number;
    logo!: string | undefined;
    employerTypeId!: number | undefined;
    accountTypeId!: number;
    isPlanActivated!: boolean;
    isTrial!: boolean;
    subscriptionPlanId!: number | undefined;
    lastBillingDate!: Date | undefined;
    lastPaymentDate!: Date | undefined;
    trialDueDate!: Date | undefined;
    licenseUsage!: number;
    code!: string | undefined;
    modified!: Date | undefined;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    jobs!: Job[] | undefined;

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.contactPerson = _data["contactPerson"];
            this.email = _data["email"];
            this.mobile = _data["mobile"];
            this.nowRecruiting = _data["nowRecruiting"];
            this.registered = _data["registered"];
            this.sectorId = _data["sectorId"];
            this.logo = _data["logo"];
            this.employerTypeId = _data["employerTypeId"];
            this.accountTypeId = _data["accountTypeId"];
            this.isPlanActivated = _data["isPlanActivated"];
            this.isTrial = _data["isTrial"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.lastBillingDate = _data["lastBillingDate"] ? new Date(_data["lastBillingDate"].toString()) : <any>undefined;
            this.lastPaymentDate = _data["lastPaymentDate"] ? new Date(_data["lastPaymentDate"].toString()) : <any>undefined;
            this.trialDueDate = _data["trialDueDate"] ? new Date(_data["trialDueDate"].toString()) : <any>undefined;
            this.licenseUsage = _data["licenseUsage"];
            this.code = _data["code"];
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["jobs"])) {
                this.jobs = [] as any;
                for (let item of _data["jobs"])
                    this.jobs!.push(Job.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["contactPerson"] = this.contactPerson;
        data["email"] = this.email;
        data["mobile"] = this.mobile;
        data["nowRecruiting"] = this.nowRecruiting;
        data["registered"] = this.registered;
        data["sectorId"] = this.sectorId;
        data["logo"] = this.logo;
        data["employerTypeId"] = this.employerTypeId;
        data["accountTypeId"] = this.accountTypeId;
        data["isPlanActivated"] = this.isPlanActivated;
        data["isTrial"] = this.isTrial;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["lastBillingDate"] = this.lastBillingDate ? this.lastBillingDate.toISOString() : <any>undefined;
        data["lastPaymentDate"] = this.lastPaymentDate ? this.lastPaymentDate.toISOString() : <any>undefined;
        data["trialDueDate"] = this.trialDueDate ? this.trialDueDate.toISOString() : <any>undefined;
        data["licenseUsage"] = this.licenseUsage;
        data["code"] = this.code;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.jobs)) {
            data["jobs"] = [];
            for (let item of this.jobs)
                data["jobs"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Company {
        const json = this.toJSON();
        let result = new Company();
        result.init(json);
        return result;
    }
}

export interface ICompany {
    id: number;
    name: string | undefined;
    contactPerson: string | undefined;
    email: string | undefined;
    mobile: string | undefined;
    nowRecruiting: boolean;
    registered: boolean;
    sectorId: number;
    logo: string | undefined;
    employerTypeId: number | undefined;
    accountTypeId: number;
    isPlanActivated: boolean;
    isTrial: boolean;
    subscriptionPlanId: number | undefined;
    lastBillingDate: Date | undefined;
    lastPaymentDate: Date | undefined;
    trialDueDate: Date | undefined;
    licenseUsage: number;
    code: string | undefined;
    modified: Date | undefined;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    jobs: Job[] | undefined;
}

export class CompanyGroup implements ICompanyGroup {
    id!: number;
    name!: string | undefined;
    company!: Company;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICompanyGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): CompanyGroup {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): CompanyGroup {
        const json = this.toJSON();
        let result = new CompanyGroup();
        result.init(json);
        return result;
    }
}

export interface ICompanyGroup {
    id: number;
    name: string | undefined;
    company: Company;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class GroupApplicant implements IGroupApplicant {
    registeredUserId!: number;
    companyGroupId!: number;
    companyGroup!: CompanyGroup;
    registeredUser!: RegisteredUser;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IGroupApplicant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registeredUserId = _data["registeredUserId"];
            this.companyGroupId = _data["companyGroupId"];
            this.companyGroup = _data["companyGroup"] ? CompanyGroup.fromJS(_data["companyGroup"]) : <any>undefined;
            this.registeredUser = _data["registeredUser"] ? RegisteredUser.fromJS(_data["registeredUser"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): GroupApplicant {
        data = typeof data === 'object' ? data : {};
        let result = new GroupApplicant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registeredUserId"] = this.registeredUserId;
        data["companyGroupId"] = this.companyGroupId;
        data["companyGroup"] = this.companyGroup ? this.companyGroup.toJSON() : <any>undefined;
        data["registeredUser"] = this.registeredUser ? this.registeredUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): GroupApplicant {
        const json = this.toJSON();
        let result = new GroupApplicant();
        result.init(json);
        return result;
    }
}

export interface IGroupApplicant {
    registeredUserId: number;
    companyGroupId: number;
    companyGroup: CompanyGroup;
    registeredUser: RegisteredUser;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ProfessionalBody implements IProfessionalBody {
    sectorId!: number;
    name!: string | undefined;
    code!: string | undefined;
    website!: string | undefined;
    certifications!: Certification[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IProfessionalBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sectorId = _data["sectorId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.website = _data["website"];
            if (Array.isArray(_data["certifications"])) {
                this.certifications = [] as any;
                for (let item of _data["certifications"])
                    this.certifications!.push(Certification.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ProfessionalBody {
        data = typeof data === 'object' ? data : {};
        let result = new ProfessionalBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sectorId"] = this.sectorId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["website"] = this.website;
        if (Array.isArray(this.certifications)) {
            data["certifications"] = [];
            for (let item of this.certifications)
                data["certifications"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ProfessionalBody {
        const json = this.toJSON();
        let result = new ProfessionalBody();
        result.init(json);
        return result;
    }
}

export interface IProfessionalBody {
    sectorId: number;
    name: string | undefined;
    code: string | undefined;
    website: string | undefined;
    certifications: Certification[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ApplicantCertification implements IApplicantCertification {
    registeredUserId!: number;
    year!: number;
    certificationId!: number;
    certificationName!: string | undefined;
    certification!: Certification;
    registeredUser!: RegisteredUser;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IApplicantCertification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registeredUserId = _data["registeredUserId"];
            this.year = _data["year"];
            this.certificationId = _data["certificationId"];
            this.certificationName = _data["certificationName"];
            this.certification = _data["certification"] ? Certification.fromJS(_data["certification"]) : <any>undefined;
            this.registeredUser = _data["registeredUser"] ? RegisteredUser.fromJS(_data["registeredUser"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ApplicantCertification {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicantCertification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registeredUserId"] = this.registeredUserId;
        data["year"] = this.year;
        data["certificationId"] = this.certificationId;
        data["certificationName"] = this.certificationName;
        data["certification"] = this.certification ? this.certification.toJSON() : <any>undefined;
        data["registeredUser"] = this.registeredUser ? this.registeredUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ApplicantCertification {
        const json = this.toJSON();
        let result = new ApplicantCertification();
        result.init(json);
        return result;
    }
}

export interface IApplicantCertification {
    registeredUserId: number;
    year: number;
    certificationId: number;
    certificationName: string | undefined;
    certification: Certification;
    registeredUser: RegisteredUser;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Certification implements ICertification {
    professionalBodyId!: number;
    name!: string | undefined;
    code!: string | undefined;
    point!: number | undefined;
    professionalBody!: ProfessionalBody;
    applicantCertifications!: ApplicantCertification[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICertification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.professionalBodyId = _data["professionalBodyId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.point = _data["point"];
            this.professionalBody = _data["professionalBody"] ? ProfessionalBody.fromJS(_data["professionalBody"]) : <any>undefined;
            if (Array.isArray(_data["applicantCertifications"])) {
                this.applicantCertifications = [] as any;
                for (let item of _data["applicantCertifications"])
                    this.applicantCertifications!.push(ApplicantCertification.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Certification {
        data = typeof data === 'object' ? data : {};
        let result = new Certification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["professionalBodyId"] = this.professionalBodyId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["point"] = this.point;
        data["professionalBody"] = this.professionalBody ? this.professionalBody.toJSON() : <any>undefined;
        if (Array.isArray(this.applicantCertifications)) {
            data["applicantCertifications"] = [];
            for (let item of this.applicantCertifications)
                data["applicantCertifications"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Certification {
        const json = this.toJSON();
        let result = new Certification();
        result.init(json);
        return result;
    }
}

export interface ICertification {
    professionalBodyId: number;
    name: string | undefined;
    code: string | undefined;
    point: number | undefined;
    professionalBody: ProfessionalBody;
    applicantCertifications: ApplicantCertification[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class CoverLetter implements ICoverLetter {
    registeredUserId!: number;
    name!: string | undefined;
    content!: string | undefined;
    registeredUser!: RegisteredUser;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICoverLetter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registeredUserId = _data["registeredUserId"];
            this.name = _data["name"];
            this.content = _data["content"];
            this.registeredUser = _data["registeredUser"] ? RegisteredUser.fromJS(_data["registeredUser"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): CoverLetter {
        data = typeof data === 'object' ? data : {};
        let result = new CoverLetter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registeredUserId"] = this.registeredUserId;
        data["name"] = this.name;
        data["content"] = this.content;
        data["registeredUser"] = this.registeredUser ? this.registeredUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): CoverLetter {
        const json = this.toJSON();
        let result = new CoverLetter();
        result.init(json);
        return result;
    }
}

export interface ICoverLetter {
    registeredUserId: number;
    name: string | undefined;
    content: string | undefined;
    registeredUser: RegisteredUser;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class SkillArea implements ISkillArea {
    name!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ISkillArea) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): SkillArea {
        data = typeof data === 'object' ? data : {};
        let result = new SkillArea();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): SkillArea {
        const json = this.toJSON();
        let result = new SkillArea();
        result.init(json);
        return result;
    }
}

export interface ISkillArea {
    name: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class DesiredFunctionalArea implements IDesiredFunctionalArea {
    registeredUserId!: number;
    skillAreaId!: number;
    registeredUser!: RegisteredUser;
    skillArea!: SkillArea;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDesiredFunctionalArea) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registeredUserId = _data["registeredUserId"];
            this.skillAreaId = _data["skillAreaId"];
            this.registeredUser = _data["registeredUser"] ? RegisteredUser.fromJS(_data["registeredUser"]) : <any>undefined;
            this.skillArea = _data["skillArea"] ? SkillArea.fromJS(_data["skillArea"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): DesiredFunctionalArea {
        data = typeof data === 'object' ? data : {};
        let result = new DesiredFunctionalArea();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registeredUserId"] = this.registeredUserId;
        data["skillAreaId"] = this.skillAreaId;
        data["registeredUser"] = this.registeredUser ? this.registeredUser.toJSON() : <any>undefined;
        data["skillArea"] = this.skillArea ? this.skillArea.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): DesiredFunctionalArea {
        const json = this.toJSON();
        let result = new DesiredFunctionalArea();
        result.init(json);
        return result;
    }
}

export interface IDesiredFunctionalArea {
    registeredUserId: number;
    skillAreaId: number;
    registeredUser: RegisteredUser;
    skillArea: SkillArea;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class State implements IState {
    name!: string | undefined;
    visibleToJobSeekers!: boolean | undefined;
    countryId!: number | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.visibleToJobSeekers = _data["visibleToJobSeekers"];
            this.countryId = _data["countryId"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): State {
        data = typeof data === 'object' ? data : {};
        let result = new State();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["visibleToJobSeekers"] = this.visibleToJobSeekers;
        data["countryId"] = this.countryId;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): State {
        const json = this.toJSON();
        let result = new State();
        result.init(json);
        return result;
    }
}

export interface IState {
    name: string | undefined;
    visibleToJobSeekers: boolean | undefined;
    countryId: number | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class DesiredJobLocation implements IDesiredJobLocation {
    registeredUserId!: number;
    stateId!: number;
    registeredUser!: RegisteredUser;
    state!: State;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDesiredJobLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registeredUserId = _data["registeredUserId"];
            this.stateId = _data["stateId"];
            this.registeredUser = _data["registeredUser"] ? RegisteredUser.fromJS(_data["registeredUser"]) : <any>undefined;
            this.state = _data["state"] ? State.fromJS(_data["state"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): DesiredJobLocation {
        data = typeof data === 'object' ? data : {};
        let result = new DesiredJobLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registeredUserId"] = this.registeredUserId;
        data["stateId"] = this.stateId;
        data["registeredUser"] = this.registeredUser ? this.registeredUser.toJSON() : <any>undefined;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): DesiredJobLocation {
        const json = this.toJSON();
        let result = new DesiredJobLocation();
        result.init(json);
        return result;
    }
}

export interface IDesiredJobLocation {
    registeredUserId: number;
    stateId: number;
    registeredUser: RegisteredUser;
    state: State;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class JobType implements IJobType {
    id!: number;
    name!: string | undefined;
    dateCreated!: Date;
    modified!: Date | undefined;
    isDeleted!: boolean;
    isActive!: boolean;
    jobs!: Job[] | undefined;

    constructor(data?: IJobType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["jobs"])) {
                this.jobs = [] as any;
                for (let item of _data["jobs"])
                    this.jobs!.push(Job.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JobType {
        data = typeof data === 'object' ? data : {};
        let result = new JobType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.jobs)) {
            data["jobs"] = [];
            for (let item of this.jobs)
                data["jobs"].push(item.toJSON());
        }
        return data; 
    }

    clone(): JobType {
        const json = this.toJSON();
        let result = new JobType();
        result.init(json);
        return result;
    }
}

export interface IJobType {
    id: number;
    name: string | undefined;
    dateCreated: Date;
    modified: Date | undefined;
    isDeleted: boolean;
    isActive: boolean;
    jobs: Job[] | undefined;
}

export class DesiredJobType implements IDesiredJobType {
    registeredUserId!: number;
    jobTypeId!: number;
    jobType!: JobType;
    registeredUser!: RegisteredUser;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDesiredJobType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registeredUserId = _data["registeredUserId"];
            this.jobTypeId = _data["jobTypeId"];
            this.jobType = _data["jobType"] ? JobType.fromJS(_data["jobType"]) : <any>undefined;
            this.registeredUser = _data["registeredUser"] ? RegisteredUser.fromJS(_data["registeredUser"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): DesiredJobType {
        data = typeof data === 'object' ? data : {};
        let result = new DesiredJobType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registeredUserId"] = this.registeredUserId;
        data["jobTypeId"] = this.jobTypeId;
        data["jobType"] = this.jobType ? this.jobType.toJSON() : <any>undefined;
        data["registeredUser"] = this.registeredUser ? this.registeredUser.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): DesiredJobType {
        const json = this.toJSON();
        let result = new DesiredJobType();
        result.init(json);
        return result;
    }
}

export interface IDesiredJobType {
    registeredUserId: number;
    jobTypeId: number;
    jobType: JobType;
    registeredUser: RegisteredUser;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class VisibilityMode implements IVisibilityMode {
    id!: number;
    name!: string | undefined;
    registeredUsers!: RegisteredUser[] | undefined;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IVisibilityMode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["registeredUsers"])) {
                this.registeredUsers = [] as any;
                for (let item of _data["registeredUsers"])
                    this.registeredUsers!.push(RegisteredUser.fromJS(item));
            }
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): VisibilityMode {
        data = typeof data === 'object' ? data : {};
        let result = new VisibilityMode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.registeredUsers)) {
            data["registeredUsers"] = [];
            for (let item of this.registeredUsers)
                data["registeredUsers"].push(item.toJSON());
        }
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): VisibilityMode {
        const json = this.toJSON();
        let result = new VisibilityMode();
        result.init(json);
        return result;
    }
}

export interface IVisibilityMode {
    id: number;
    name: string | undefined;
    registeredUsers: RegisteredUser[] | undefined;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class WarehouseSection implements IWarehouseSection {
    name!: string | undefined;
    description!: string | undefined;
    company!: Company;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IWarehouseSection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): WarehouseSection {
        data = typeof data === 'object' ? data : {};
        let result = new WarehouseSection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): WarehouseSection {
        const json = this.toJSON();
        let result = new WarehouseSection();
        result.init(json);
        return result;
    }
}

export interface IWarehouseSection {
    name: string | undefined;
    description: string | undefined;
    company: Company;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class UserWarehouseSection implements IUserWarehouseSection {
    registeredUserId!: number;
    warehouseSectionId!: number;
    registeredUser!: RegisteredUser;
    warehouseSection!: WarehouseSection;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IUserWarehouseSection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registeredUserId = _data["registeredUserId"];
            this.warehouseSectionId = _data["warehouseSectionId"];
            this.registeredUser = _data["registeredUser"] ? RegisteredUser.fromJS(_data["registeredUser"]) : <any>undefined;
            this.warehouseSection = _data["warehouseSection"] ? WarehouseSection.fromJS(_data["warehouseSection"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): UserWarehouseSection {
        data = typeof data === 'object' ? data : {};
        let result = new UserWarehouseSection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registeredUserId"] = this.registeredUserId;
        data["warehouseSectionId"] = this.warehouseSectionId;
        data["registeredUser"] = this.registeredUser ? this.registeredUser.toJSON() : <any>undefined;
        data["warehouseSection"] = this.warehouseSection ? this.warehouseSection.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): UserWarehouseSection {
        const json = this.toJSON();
        let result = new UserWarehouseSection();
        result.init(json);
        return result;
    }
}

export interface IUserWarehouseSection {
    registeredUserId: number;
    warehouseSectionId: number;
    registeredUser: RegisteredUser;
    warehouseSection: WarehouseSection;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class WorkExprience implements IWorkExprience {
    jobDescription!: string | undefined;
    startDate!: Date;
    from!: number | undefined;
    to!: number | undefined;
    registeredUserId!: number;
    position!: string | undefined;
    skillAreaId!: number | undefined;
    company!: string | undefined;
    sectorId!: number | undefined;
    isPresentEmployment!: boolean | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IWorkExprience) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobDescription = _data["jobDescription"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.from = _data["from"];
            this.to = _data["to"];
            this.registeredUserId = _data["registeredUserId"];
            this.position = _data["position"];
            this.skillAreaId = _data["skillAreaId"];
            this.company = _data["company"];
            this.sectorId = _data["sectorId"];
            this.isPresentEmployment = _data["isPresentEmployment"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): WorkExprience {
        data = typeof data === 'object' ? data : {};
        let result = new WorkExprience();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobDescription"] = this.jobDescription;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["from"] = this.from;
        data["to"] = this.to;
        data["registeredUserId"] = this.registeredUserId;
        data["position"] = this.position;
        data["skillAreaId"] = this.skillAreaId;
        data["company"] = this.company;
        data["sectorId"] = this.sectorId;
        data["isPresentEmployment"] = this.isPresentEmployment;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): WorkExprience {
        const json = this.toJSON();
        let result = new WorkExprience();
        result.init(json);
        return result;
    }
}

export interface IWorkExprience {
    jobDescription: string | undefined;
    startDate: Date;
    from: number | undefined;
    to: number | undefined;
    registeredUserId: number;
    position: string | undefined;
    skillAreaId: number | undefined;
    company: string | undefined;
    sectorId: number | undefined;
    isPresentEmployment: boolean | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class RegisteredUser implements IRegisteredUser {
    titleId!: number;
    firstName!: string | undefined;
    lastName!: string | undefined;
    otherName!: string | undefined;
    email!: string | undefined;
    mobile!: string | undefined;
    birthDate!: Date | undefined;
    stateOfResidentId!: number | undefined;
    stateOfInterestId!: number | undefined;
    nationalityId!: number | undefined;
    yearOfExperience!: number | undefined;
    gender!: number | undefined;
    sex!: string | undefined;
    title!: string | undefined;
    userId!: number;
    age!: number;
    applicantType!: number;
    countryId!: number | undefined;
    skills!: string | undefined;
    educationId!: number | undefined;
    lastUpdate!: Date | undefined;
    password!: string | undefined;
    nyscStatus!: number | undefined;
    activated!: Date | undefined;
    workAchievements!: string | undefined;
    cvName!: string | undefined;
    cvMimeType!: string | undefined;
    alertModeId!: number | undefined;
    desiredSalaryCurrency!: string | undefined;
    desiredSalaryAnnum!: number | undefined;
    desiredSalaryNegotiable!: number | undefined;
    willingToRelocate!: number | undefined;
    photoName!: string | undefined;
    videoUrl!: string | undefined;
    youtubeVideoUrl!: string | undefined;
    photoMimeType!: string | undefined;
    visibilityModeId!: number | undefined;
    activationCode!: string | undefined;
    jobMatchAlertId!: number | undefined;
    considerExpForJobAlert!: boolean | undefined;
    completeProfile!: boolean | undefined;
    minJobExpForAlert!: number | undefined;
    alertmode!: Alertmode;
    appliedApplicants!: AppliedApplicant[] | undefined;
    country!: Country;
    educations!: Education[] | undefined;
    groupApplicants!: GroupApplicant[] | undefined;
    certifications!: Certification[] | undefined;
    coverLetters!: CoverLetter[] | undefined;
    desiredFunctionalAreas!: DesiredFunctionalArea[] | undefined;
    desiredJobLocations!: DesiredJobLocation[] | undefined;
    desiredJobTypes!: DesiredJobType[] | undefined;
    visibilityMode!: VisibilityMode;
    userWarehouseSections!: UserWarehouseSection[] | undefined;
    workExpriences!: WorkExprience[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRegisteredUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.titleId = _data["titleId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.otherName = _data["otherName"];
            this.email = _data["email"];
            this.mobile = _data["mobile"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.stateOfResidentId = _data["stateOfResidentId"];
            this.stateOfInterestId = _data["stateOfInterestId"];
            this.nationalityId = _data["nationalityId"];
            this.yearOfExperience = _data["yearOfExperience"];
            this.gender = _data["gender"];
            this.sex = _data["sex"];
            this.title = _data["title"];
            this.userId = _data["userId"];
            this.age = _data["age"];
            this.applicantType = _data["applicantType"];
            this.countryId = _data["countryId"];
            this.skills = _data["skills"];
            this.educationId = _data["educationId"];
            this.lastUpdate = _data["lastUpdate"] ? new Date(_data["lastUpdate"].toString()) : <any>undefined;
            this.password = _data["password"];
            this.nyscStatus = _data["nyscStatus"];
            this.activated = _data["activated"] ? new Date(_data["activated"].toString()) : <any>undefined;
            this.workAchievements = _data["workAchievements"];
            this.cvName = _data["cvName"];
            this.cvMimeType = _data["cvMimeType"];
            this.alertModeId = _data["alertModeId"];
            this.desiredSalaryCurrency = _data["desiredSalaryCurrency"];
            this.desiredSalaryAnnum = _data["desiredSalaryAnnum"];
            this.desiredSalaryNegotiable = _data["desiredSalaryNegotiable"];
            this.willingToRelocate = _data["willingToRelocate"];
            this.photoName = _data["photoName"];
            this.videoUrl = _data["videoUrl"];
            this.youtubeVideoUrl = _data["youtubeVideoUrl"];
            this.photoMimeType = _data["photoMimeType"];
            this.visibilityModeId = _data["visibilityModeId"];
            this.activationCode = _data["activationCode"];
            this.jobMatchAlertId = _data["jobMatchAlertId"];
            this.considerExpForJobAlert = _data["considerExpForJobAlert"];
            this.completeProfile = _data["completeProfile"];
            this.minJobExpForAlert = _data["minJobExpForAlert"];
            this.alertmode = _data["alertmode"] ? Alertmode.fromJS(_data["alertmode"]) : <any>undefined;
            if (Array.isArray(_data["appliedApplicants"])) {
                this.appliedApplicants = [] as any;
                for (let item of _data["appliedApplicants"])
                    this.appliedApplicants!.push(AppliedApplicant.fromJS(item));
            }
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : <any>undefined;
            if (Array.isArray(_data["educations"])) {
                this.educations = [] as any;
                for (let item of _data["educations"])
                    this.educations!.push(Education.fromJS(item));
            }
            if (Array.isArray(_data["groupApplicants"])) {
                this.groupApplicants = [] as any;
                for (let item of _data["groupApplicants"])
                    this.groupApplicants!.push(GroupApplicant.fromJS(item));
            }
            if (Array.isArray(_data["certifications"])) {
                this.certifications = [] as any;
                for (let item of _data["certifications"])
                    this.certifications!.push(Certification.fromJS(item));
            }
            if (Array.isArray(_data["coverLetters"])) {
                this.coverLetters = [] as any;
                for (let item of _data["coverLetters"])
                    this.coverLetters!.push(CoverLetter.fromJS(item));
            }
            if (Array.isArray(_data["desiredFunctionalAreas"])) {
                this.desiredFunctionalAreas = [] as any;
                for (let item of _data["desiredFunctionalAreas"])
                    this.desiredFunctionalAreas!.push(DesiredFunctionalArea.fromJS(item));
            }
            if (Array.isArray(_data["desiredJobLocations"])) {
                this.desiredJobLocations = [] as any;
                for (let item of _data["desiredJobLocations"])
                    this.desiredJobLocations!.push(DesiredJobLocation.fromJS(item));
            }
            if (Array.isArray(_data["desiredJobTypes"])) {
                this.desiredJobTypes = [] as any;
                for (let item of _data["desiredJobTypes"])
                    this.desiredJobTypes!.push(DesiredJobType.fromJS(item));
            }
            this.visibilityMode = _data["visibilityMode"] ? VisibilityMode.fromJS(_data["visibilityMode"]) : <any>undefined;
            if (Array.isArray(_data["userWarehouseSections"])) {
                this.userWarehouseSections = [] as any;
                for (let item of _data["userWarehouseSections"])
                    this.userWarehouseSections!.push(UserWarehouseSection.fromJS(item));
            }
            if (Array.isArray(_data["workExpriences"])) {
                this.workExpriences = [] as any;
                for (let item of _data["workExpriences"])
                    this.workExpriences!.push(WorkExprience.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): RegisteredUser {
        data = typeof data === 'object' ? data : {};
        let result = new RegisteredUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["titleId"] = this.titleId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["otherName"] = this.otherName;
        data["email"] = this.email;
        data["mobile"] = this.mobile;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["stateOfResidentId"] = this.stateOfResidentId;
        data["stateOfInterestId"] = this.stateOfInterestId;
        data["nationalityId"] = this.nationalityId;
        data["yearOfExperience"] = this.yearOfExperience;
        data["gender"] = this.gender;
        data["sex"] = this.sex;
        data["title"] = this.title;
        data["userId"] = this.userId;
        data["age"] = this.age;
        data["applicantType"] = this.applicantType;
        data["countryId"] = this.countryId;
        data["skills"] = this.skills;
        data["educationId"] = this.educationId;
        data["lastUpdate"] = this.lastUpdate ? this.lastUpdate.toISOString() : <any>undefined;
        data["password"] = this.password;
        data["nyscStatus"] = this.nyscStatus;
        data["activated"] = this.activated ? this.activated.toISOString() : <any>undefined;
        data["workAchievements"] = this.workAchievements;
        data["cvName"] = this.cvName;
        data["cvMimeType"] = this.cvMimeType;
        data["alertModeId"] = this.alertModeId;
        data["desiredSalaryCurrency"] = this.desiredSalaryCurrency;
        data["desiredSalaryAnnum"] = this.desiredSalaryAnnum;
        data["desiredSalaryNegotiable"] = this.desiredSalaryNegotiable;
        data["willingToRelocate"] = this.willingToRelocate;
        data["photoName"] = this.photoName;
        data["videoUrl"] = this.videoUrl;
        data["youtubeVideoUrl"] = this.youtubeVideoUrl;
        data["photoMimeType"] = this.photoMimeType;
        data["visibilityModeId"] = this.visibilityModeId;
        data["activationCode"] = this.activationCode;
        data["jobMatchAlertId"] = this.jobMatchAlertId;
        data["considerExpForJobAlert"] = this.considerExpForJobAlert;
        data["completeProfile"] = this.completeProfile;
        data["minJobExpForAlert"] = this.minJobExpForAlert;
        data["alertmode"] = this.alertmode ? this.alertmode.toJSON() : <any>undefined;
        if (Array.isArray(this.appliedApplicants)) {
            data["appliedApplicants"] = [];
            for (let item of this.appliedApplicants)
                data["appliedApplicants"].push(item.toJSON());
        }
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        if (Array.isArray(this.educations)) {
            data["educations"] = [];
            for (let item of this.educations)
                data["educations"].push(item.toJSON());
        }
        if (Array.isArray(this.groupApplicants)) {
            data["groupApplicants"] = [];
            for (let item of this.groupApplicants)
                data["groupApplicants"].push(item.toJSON());
        }
        if (Array.isArray(this.certifications)) {
            data["certifications"] = [];
            for (let item of this.certifications)
                data["certifications"].push(item.toJSON());
        }
        if (Array.isArray(this.coverLetters)) {
            data["coverLetters"] = [];
            for (let item of this.coverLetters)
                data["coverLetters"].push(item.toJSON());
        }
        if (Array.isArray(this.desiredFunctionalAreas)) {
            data["desiredFunctionalAreas"] = [];
            for (let item of this.desiredFunctionalAreas)
                data["desiredFunctionalAreas"].push(item.toJSON());
        }
        if (Array.isArray(this.desiredJobLocations)) {
            data["desiredJobLocations"] = [];
            for (let item of this.desiredJobLocations)
                data["desiredJobLocations"].push(item.toJSON());
        }
        if (Array.isArray(this.desiredJobTypes)) {
            data["desiredJobTypes"] = [];
            for (let item of this.desiredJobTypes)
                data["desiredJobTypes"].push(item.toJSON());
        }
        data["visibilityMode"] = this.visibilityMode ? this.visibilityMode.toJSON() : <any>undefined;
        if (Array.isArray(this.userWarehouseSections)) {
            data["userWarehouseSections"] = [];
            for (let item of this.userWarehouseSections)
                data["userWarehouseSections"].push(item.toJSON());
        }
        if (Array.isArray(this.workExpriences)) {
            data["workExpriences"] = [];
            for (let item of this.workExpriences)
                data["workExpriences"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): RegisteredUser {
        const json = this.toJSON();
        let result = new RegisteredUser();
        result.init(json);
        return result;
    }
}

export interface IRegisteredUser {
    titleId: number;
    firstName: string | undefined;
    lastName: string | undefined;
    otherName: string | undefined;
    email: string | undefined;
    mobile: string | undefined;
    birthDate: Date | undefined;
    stateOfResidentId: number | undefined;
    stateOfInterestId: number | undefined;
    nationalityId: number | undefined;
    yearOfExperience: number | undefined;
    gender: number | undefined;
    sex: string | undefined;
    title: string | undefined;
    userId: number;
    age: number;
    applicantType: number;
    countryId: number | undefined;
    skills: string | undefined;
    educationId: number | undefined;
    lastUpdate: Date | undefined;
    password: string | undefined;
    nyscStatus: number | undefined;
    activated: Date | undefined;
    workAchievements: string | undefined;
    cvName: string | undefined;
    cvMimeType: string | undefined;
    alertModeId: number | undefined;
    desiredSalaryCurrency: string | undefined;
    desiredSalaryAnnum: number | undefined;
    desiredSalaryNegotiable: number | undefined;
    willingToRelocate: number | undefined;
    photoName: string | undefined;
    videoUrl: string | undefined;
    youtubeVideoUrl: string | undefined;
    photoMimeType: string | undefined;
    visibilityModeId: number | undefined;
    activationCode: string | undefined;
    jobMatchAlertId: number | undefined;
    considerExpForJobAlert: boolean | undefined;
    completeProfile: boolean | undefined;
    minJobExpForAlert: number | undefined;
    alertmode: Alertmode;
    appliedApplicants: AppliedApplicant[] | undefined;
    country: Country;
    educations: Education[] | undefined;
    groupApplicants: GroupApplicant[] | undefined;
    certifications: Certification[] | undefined;
    coverLetters: CoverLetter[] | undefined;
    desiredFunctionalAreas: DesiredFunctionalArea[] | undefined;
    desiredJobLocations: DesiredJobLocation[] | undefined;
    desiredJobTypes: DesiredJobType[] | undefined;
    visibilityMode: VisibilityMode;
    userWarehouseSections: UserWarehouseSection[] | undefined;
    workExpriences: WorkExprience[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Country implements ICountry {
    name!: string | undefined;
    code!: string | undefined;
    isDefault!: boolean;
    registeredUsers!: RegisteredUser[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.isDefault = _data["isDefault"];
            if (Array.isArray(_data["registeredUsers"])) {
                this.registeredUsers = [] as any;
                for (let item of _data["registeredUsers"])
                    this.registeredUsers!.push(RegisteredUser.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["isDefault"] = this.isDefault;
        if (Array.isArray(this.registeredUsers)) {
            data["registeredUsers"] = [];
            for (let item of this.registeredUsers)
                data["registeredUsers"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Country {
        const json = this.toJSON();
        let result = new Country();
        result.init(json);
        return result;
    }
}

export interface ICountry {
    name: string | undefined;
    code: string | undefined;
    isDefault: boolean;
    registeredUsers: RegisteredUser[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class CountryOdataResult implements ICountryOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: Country[] | undefined;

    constructor(data?: ICountryOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Country.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CountryOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new CountryOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CountryOdataResult {
        const json = this.toJSON();
        let result = new CountryOdataResult();
        result.init(json);
        return result;
    }
}

export interface ICountryOdataResult {
    id: number;
    odataContext: string | undefined;
    value: Country[] | undefined;
}

export class CourseOdataResult implements ICourseOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: Course[] | undefined;

    constructor(data?: ICourseOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Course.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CourseOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new CourseOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CourseOdataResult {
        const json = this.toJSON();
        let result = new CourseOdataResult();
        result.init(json);
        return result;
    }
}

export interface ICourseOdataResult {
    id: number;
    odataContext: string | undefined;
    value: Course[] | undefined;
}

export class Currency implements ICurrency {
    name!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICurrency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Currency {
        data = typeof data === 'object' ? data : {};
        let result = new Currency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Currency {
        const json = this.toJSON();
        let result = new Currency();
        result.init(json);
        return result;
    }
}

export interface ICurrency {
    name: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class CurrencyOdataResult implements ICurrencyOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: Currency[] | undefined;

    constructor(data?: ICurrencyOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Currency.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CurrencyOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CurrencyOdataResult {
        const json = this.toJSON();
        let result = new CurrencyOdataResult();
        result.init(json);
        return result;
    }
}

export interface ICurrencyOdataResult {
    id: number;
    odataContext: string | undefined;
    value: Currency[] | undefined;
}

export class EmployerType implements IEmployerType {
    name!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployerType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmployerType {
        data = typeof data === 'object' ? data : {};
        let result = new EmployerType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmployerType {
        const json = this.toJSON();
        let result = new EmployerType();
        result.init(json);
        return result;
    }
}

export interface IEmployerType {
    name: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployerTypeOdataResult implements IEmployerTypeOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: EmployerType[] | undefined;

    constructor(data?: IEmployerTypeOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(EmployerType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmployerTypeOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmployerTypeOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EmployerTypeOdataResult {
        const json = this.toJSON();
        let result = new EmployerTypeOdataResult();
        result.init(json);
        return result;
    }
}

export interface IEmployerTypeOdataResult {
    id: number;
    odataContext: string | undefined;
    value: EmployerType[] | undefined;
}

export class Grade implements IGrade {
    name!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IGrade) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Grade {
        data = typeof data === 'object' ? data : {};
        let result = new Grade();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Grade {
        const json = this.toJSON();
        let result = new Grade();
        result.init(json);
        return result;
    }
}

export interface IGrade {
    name: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class GradeOdataResult implements IGradeOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: Grade[] | undefined;

    constructor(data?: IGradeOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Grade.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GradeOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new GradeOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GradeOdataResult {
        const json = this.toJSON();
        let result = new GradeOdataResult();
        result.init(json);
        return result;
    }
}

export interface IGradeOdataResult {
    id: number;
    odataContext: string | undefined;
    value: Grade[] | undefined;
}

export class InstitutionOdataResult implements IInstitutionOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: Institution[] | undefined;

    constructor(data?: IInstitutionOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Institution.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InstitutionOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new InstitutionOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): InstitutionOdataResult {
        const json = this.toJSON();
        let result = new InstitutionOdataResult();
        result.init(json);
        return result;
    }
}

export interface IInstitutionOdataResult {
    id: number;
    odataContext: string | undefined;
    value: Institution[] | undefined;
}

export class JobTypeOdataResult implements IJobTypeOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: JobType[] | undefined;

    constructor(data?: IJobTypeOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(JobType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JobTypeOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new JobTypeOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): JobTypeOdataResult {
        const json = this.toJSON();
        let result = new JobTypeOdataResult();
        result.init(json);
        return result;
    }
}

export interface IJobTypeOdataResult {
    id: number;
    odataContext: string | undefined;
    value: JobType[] | undefined;
}

export class QualificationOdataResult implements IQualificationOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: Qualification[] | undefined;

    constructor(data?: IQualificationOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Qualification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QualificationOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new QualificationOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): QualificationOdataResult {
        const json = this.toJSON();
        let result = new QualificationOdataResult();
        result.init(json);
        return result;
    }
}

export interface IQualificationOdataResult {
    id: number;
    odataContext: string | undefined;
    value: Qualification[] | undefined;
}

export class ApplicationRoleDTO implements IApplicationRoleDTO {
    id!: number;
    name!: string;
    description!: string | undefined;
    isSystemRole!: boolean;

    constructor(data?: IApplicationRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isSystemRole = _data["isSystemRole"];
        }
    }

    static fromJS(data: any): ApplicationRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isSystemRole"] = this.isSystemRole;
        return data; 
    }

    clone(): ApplicationRoleDTO {
        const json = this.toJSON();
        let result = new ApplicationRoleDTO();
        result.init(json);
        return result;
    }
}

export interface IApplicationRoleDTO {
    id: number;
    name: string;
    description: string | undefined;
    isSystemRole: boolean;
}

export class ApplicationRoleDTOOdataResult implements IApplicationRoleDTOOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: ApplicationRoleDTO[] | undefined;

    constructor(data?: IApplicationRoleDTOOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(ApplicationRoleDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicationRoleDTOOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRoleDTOOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ApplicationRoleDTOOdataResult {
        const json = this.toJSON();
        let result = new ApplicationRoleDTOOdataResult();
        result.init(json);
        return result;
    }
}

export interface IApplicationRoleDTOOdataResult {
    id: number;
    odataContext: string | undefined;
    value: ApplicationRoleDTO[] | undefined;
}

export class Sector implements ISector {
    name!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ISector) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Sector {
        data = typeof data === 'object' ? data : {};
        let result = new Sector();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Sector {
        const json = this.toJSON();
        let result = new Sector();
        result.init(json);
        return result;
    }
}

export interface ISector {
    name: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class SectorOdataResult implements ISectorOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: Sector[] | undefined;

    constructor(data?: ISectorOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Sector.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SectorOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new SectorOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SectorOdataResult {
        const json = this.toJSON();
        let result = new SectorOdataResult();
        result.init(json);
        return result;
    }
}

export interface ISectorOdataResult {
    id: number;
    odataContext: string | undefined;
    value: Sector[] | undefined;
}

export class SkillAreaOdataResult implements ISkillAreaOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: SkillArea[] | undefined;

    constructor(data?: ISkillAreaOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(SkillArea.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SkillAreaOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new SkillAreaOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SkillAreaOdataResult {
        const json = this.toJSON();
        let result = new SkillAreaOdataResult();
        result.init(json);
        return result;
    }
}

export interface ISkillAreaOdataResult {
    id: number;
    odataContext: string | undefined;
    value: SkillArea[] | undefined;
}

export class StateOdataResult implements IStateOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: State[] | undefined;

    constructor(data?: IStateOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(State.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StateOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new StateOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StateOdataResult {
        const json = this.toJSON();
        let result = new StateOdataResult();
        result.init(json);
        return result;
    }
}

export interface IStateOdataResult {
    id: number;
    odataContext: string | undefined;
    value: State[] | undefined;
}

export class SubscriptionFeatureDTO implements ISubscriptionFeatureDTO {
    id!: number;
    name!: string | undefined;

    constructor(data?: ISubscriptionFeatureDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SubscriptionFeatureDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionFeatureDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): SubscriptionFeatureDTO {
        const json = this.toJSON();
        let result = new SubscriptionFeatureDTO();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionFeatureDTO {
    id: number;
    name: string | undefined;
}

export class SubscriptionPlanDTO implements ISubscriptionPlanDTO {
    id!: number;
    planCode!: string | undefined;
    name!: string | undefined;
    amount!: number;
    typeId!: number;
    totalSubscribers!: number;
    paymentUrl!: string | undefined;
    dateCreated!: Date | undefined;
    modified!: Date | undefined;
    features!: SubscriptionFeatureDTO[] | undefined;

    constructor(data?: ISubscriptionPlanDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.planCode = _data["planCode"];
            this.name = _data["name"];
            this.amount = _data["amount"];
            this.typeId = _data["typeId"];
            this.totalSubscribers = _data["totalSubscribers"];
            this.paymentUrl = _data["paymentUrl"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(SubscriptionFeatureDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubscriptionPlanDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlanDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["planCode"] = this.planCode;
        data["name"] = this.name;
        data["amount"] = this.amount;
        data["typeId"] = this.typeId;
        data["totalSubscribers"] = this.totalSubscribers;
        data["paymentUrl"] = this.paymentUrl;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SubscriptionPlanDTO {
        const json = this.toJSON();
        let result = new SubscriptionPlanDTO();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPlanDTO {
    id: number;
    planCode: string | undefined;
    name: string | undefined;
    amount: number;
    typeId: number;
    totalSubscribers: number;
    paymentUrl: string | undefined;
    dateCreated: Date | undefined;
    modified: Date | undefined;
    features: SubscriptionFeatureDTO[] | undefined;
}

export class SubscriptionPlanDTOOdataResult implements ISubscriptionPlanDTOOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: SubscriptionPlanDTO[] | undefined;

    constructor(data?: ISubscriptionPlanDTOOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(SubscriptionPlanDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubscriptionPlanDTOOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlanDTOOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SubscriptionPlanDTOOdataResult {
        const json = this.toJSON();
        let result = new SubscriptionPlanDTOOdataResult();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPlanDTOOdataResult {
    id: number;
    odataContext: string | undefined;
    value: SubscriptionPlanDTO[] | undefined;
}

export class ManageSubscriptionDTO implements IManageSubscriptionDTO {
    id!: number;
    planCode!: string | undefined;
    name!: string | undefined;
    typeId!: number;
    amount!: number;
    paymentUrl!: string | undefined;
    selectedFeatures!: string[];

    constructor(data?: IManageSubscriptionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.selectedFeatures = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.planCode = _data["planCode"];
            this.name = _data["name"];
            this.typeId = _data["typeId"];
            this.amount = _data["amount"];
            this.paymentUrl = _data["paymentUrl"];
            if (Array.isArray(_data["selectedFeatures"])) {
                this.selectedFeatures = [] as any;
                for (let item of _data["selectedFeatures"])
                    this.selectedFeatures!.push(item);
            }
        }
    }

    static fromJS(data: any): ManageSubscriptionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageSubscriptionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["planCode"] = this.planCode;
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["amount"] = this.amount;
        data["paymentUrl"] = this.paymentUrl;
        if (Array.isArray(this.selectedFeatures)) {
            data["selectedFeatures"] = [];
            for (let item of this.selectedFeatures)
                data["selectedFeatures"].push(item);
        }
        return data; 
    }

    clone(): ManageSubscriptionDTO {
        const json = this.toJSON();
        let result = new ManageSubscriptionDTO();
        result.init(json);
        return result;
    }
}

export interface IManageSubscriptionDTO {
    id: number;
    planCode: string | undefined;
    name: string | undefined;
    typeId: number;
    amount: number;
    paymentUrl: string | undefined;
    selectedFeatures: string[];
}

export class Title implements ITitle {
    id!: number;
    name!: string | undefined;
    dateCreated!: Date;
    modified!: Date | undefined;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: ITitle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): Title {
        data = typeof data === 'object' ? data : {};
        let result = new Title();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): Title {
        const json = this.toJSON();
        let result = new Title();
        result.init(json);
        return result;
    }
}

export interface ITitle {
    id: number;
    name: string | undefined;
    dateCreated: Date;
    modified: Date | undefined;
    isDeleted: boolean;
    isActive: boolean;
}

export class TitleOdataResult implements ITitleOdataResult {
    id!: number;
    odataContext!: string | undefined;
    value!: Title[] | undefined;

    constructor(data?: ITitleOdataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.odataContext = _data["odataContext"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Title.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TitleOdataResult {
        data = typeof data === 'object' ? data : {};
        let result = new TitleOdataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["odataContext"] = this.odataContext;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TitleOdataResult {
        const json = this.toJSON();
        let result = new TitleOdataResult();
        result.init(json);
        return result;
    }
}

export interface ITitleOdataResult {
    id: number;
    odataContext: string | undefined;
    value: Title[] | undefined;
}

export class ApplicationPermission implements IApplicationPermission {
    id!: number;
    name!: string | undefined;
    code!: string | undefined;
    moduleID!: number;
    applicationRolePermissions!: ApplicationRolePermission[] | undefined;

    constructor(data?: IApplicationPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.moduleID = _data["moduleID"];
            if (Array.isArray(_data["applicationRolePermissions"])) {
                this.applicationRolePermissions = [] as any;
                for (let item of _data["applicationRolePermissions"])
                    this.applicationRolePermissions!.push(ApplicationRolePermission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicationPermission {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationPermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["moduleID"] = this.moduleID;
        if (Array.isArray(this.applicationRolePermissions)) {
            data["applicationRolePermissions"] = [];
            for (let item of this.applicationRolePermissions)
                data["applicationRolePermissions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ApplicationPermission {
        const json = this.toJSON();
        let result = new ApplicationPermission();
        result.init(json);
        return result;
    }
}

export interface IApplicationPermission {
    id: number;
    name: string | undefined;
    code: string | undefined;
    moduleID: number;
    applicationRolePermissions: ApplicationRolePermission[] | undefined;
}

export class ApplicationRolePermission implements IApplicationRolePermission {
    id!: number;
    dateCreated!: Date;
    applicationRoleId!: number;
    applicationPermissionId!: number;
    applicationRole!: ApplicationRole;
    applicationPermission!: ApplicationPermission;

    constructor(data?: IApplicationRolePermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.applicationRoleId = _data["applicationRoleId"];
            this.applicationPermissionId = _data["applicationPermissionId"];
            this.applicationRole = _data["applicationRole"] ? ApplicationRole.fromJS(_data["applicationRole"]) : <any>undefined;
            this.applicationPermission = _data["applicationPermission"] ? ApplicationPermission.fromJS(_data["applicationPermission"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationRolePermission {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRolePermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["applicationRoleId"] = this.applicationRoleId;
        data["applicationPermissionId"] = this.applicationPermissionId;
        data["applicationRole"] = this.applicationRole ? this.applicationRole.toJSON() : <any>undefined;
        data["applicationPermission"] = this.applicationPermission ? this.applicationPermission.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ApplicationRolePermission {
        const json = this.toJSON();
        let result = new ApplicationRolePermission();
        result.init(json);
        return result;
    }
}

export interface IApplicationRolePermission {
    id: number;
    dateCreated: Date;
    applicationRoleId: number;
    applicationPermissionId: number;
    applicationRole: ApplicationRole;
    applicationPermission: ApplicationPermission;
}

export class ApplicationRole implements IApplicationRole {
    description!: string | undefined;
    isSystemRole!: boolean;
    applicationRolePermissions!: ApplicationRolePermission[] | undefined;
    id!: number;
    name!: string | undefined;
    normalizedName!: string | undefined;
    concurrencyStamp!: string | undefined;

    constructor(data?: IApplicationRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.isSystemRole = _data["isSystemRole"];
            if (Array.isArray(_data["applicationRolePermissions"])) {
                this.applicationRolePermissions = [] as any;
                for (let item of _data["applicationRolePermissions"])
                    this.applicationRolePermissions!.push(ApplicationRolePermission.fromJS(item));
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.normalizedName = _data["normalizedName"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): ApplicationRole {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["isSystemRole"] = this.isSystemRole;
        if (Array.isArray(this.applicationRolePermissions)) {
            data["applicationRolePermissions"] = [];
            for (let item of this.applicationRolePermissions)
                data["applicationRolePermissions"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["normalizedName"] = this.normalizedName;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data; 
    }

    clone(): ApplicationRole {
        const json = this.toJSON();
        let result = new ApplicationRole();
        result.init(json);
        return result;
    }
}

export interface IApplicationRole {
    description: string | undefined;
    isSystemRole: boolean;
    applicationRolePermissions: ApplicationRolePermission[] | undefined;
    id: number;
    name: string | undefined;
    normalizedName: string | undefined;
    concurrencyStamp: string | undefined;
}

export class RegisterUserDTO implements IRegisterUserDTO {
    firstName!: string;
    lastName!: string;
    email!: string;
    password!: string | undefined;
    phoneNumber!: string | undefined;
    selectedRoles!: string[];
    applicationRoles!: ApplicationRole[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRegisterUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.selectedRoles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.phoneNumber = _data["phoneNumber"];
            if (Array.isArray(_data["selectedRoles"])) {
                this.selectedRoles = [] as any;
                for (let item of _data["selectedRoles"])
                    this.selectedRoles!.push(item);
            }
            if (Array.isArray(_data["applicationRoles"])) {
                this.applicationRoles = [] as any;
                for (let item of _data["applicationRoles"])
                    this.applicationRoles!.push(ApplicationRole.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): RegisterUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["password"] = this.password;
        data["phoneNumber"] = this.phoneNumber;
        if (Array.isArray(this.selectedRoles)) {
            data["selectedRoles"] = [];
            for (let item of this.selectedRoles)
                data["selectedRoles"].push(item);
        }
        if (Array.isArray(this.applicationRoles)) {
            data["applicationRoles"] = [];
            for (let item of this.applicationRoles)
                data["applicationRoles"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): RegisterUserDTO {
        const json = this.toJSON();
        let result = new RegisterUserDTO();
        result.init(json);
        return result;
    }
}

export interface IRegisterUserDTO {
    firstName: string;
    lastName: string;
    email: string;
    password: string | undefined;
    phoneNumber: string | undefined;
    selectedRoles: string[];
    applicationRoles: ApplicationRole[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ApplicationUserDTO implements IApplicationUserDTO {
    id!: number;
    email!: string | undefined;
    username!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    isAdmin!: boolean;
    isTenantAdmin!: boolean;
    isEnabled!: boolean | undefined;
    lastLogin!: Date | undefined;
    companyId!: number;
    subsidiaryId!: number;
    token!: string | undefined;
    apiSessionId!: string | undefined;
    lastComputerName!: string | undefined;

    constructor(data?: IApplicationUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.username = _data["username"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.isAdmin = _data["isAdmin"];
            this.isTenantAdmin = _data["isTenantAdmin"];
            this.isEnabled = _data["isEnabled"];
            this.lastLogin = _data["lastLogin"] ? new Date(_data["lastLogin"].toString()) : <any>undefined;
            this.companyId = _data["companyId"];
            this.subsidiaryId = _data["subsidiaryId"];
            this.token = _data["token"];
            this.apiSessionId = _data["apiSessionId"];
            this.lastComputerName = _data["lastComputerName"];
        }
    }

    static fromJS(data: any): ApplicationUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["username"] = this.username;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["isAdmin"] = this.isAdmin;
        data["isTenantAdmin"] = this.isTenantAdmin;
        data["isEnabled"] = this.isEnabled;
        data["lastLogin"] = this.lastLogin ? this.lastLogin.toISOString() : <any>undefined;
        data["companyId"] = this.companyId;
        data["subsidiaryId"] = this.subsidiaryId;
        data["token"] = this.token;
        data["apiSessionId"] = this.apiSessionId;
        data["lastComputerName"] = this.lastComputerName;
        return data; 
    }

    clone(): ApplicationUserDTO {
        const json = this.toJSON();
        let result = new ApplicationUserDTO();
        result.init(json);
        return result;
    }
}

export interface IApplicationUserDTO {
    id: number;
    email: string | undefined;
    username: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    isAdmin: boolean;
    isTenantAdmin: boolean;
    isEnabled: boolean | undefined;
    lastLogin: Date | undefined;
    companyId: number;
    subsidiaryId: number;
    token: string | undefined;
    apiSessionId: string | undefined;
    lastComputerName: string | undefined;
}

export class ApplicationUserDTOIListApiResult implements IApplicationUserDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ApplicationUserDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IApplicationUserDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ApplicationUserDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ApplicationUserDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ApplicationUserDTOIListApiResult {
        const json = this.toJSON();
        let result = new ApplicationUserDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IApplicationUserDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ApplicationUserDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}